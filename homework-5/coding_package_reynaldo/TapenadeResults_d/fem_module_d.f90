!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.15 (master) - 15 Apr 2020 11:54
!
MODULE FEM_MODULE_D
  IMPLICIT NONE
  REAL, PARAMETER :: zero=0.0
  REAL, PARAMETER :: pi=3.1415926535897932384626
  REAL, PARAMETER :: eps=EPSILON(zero)

CONTAINS
!  Differentiation of beam_stiffness_matrix in forward (tangent) mode:
!   variations   of useful results: ki ii
!   with respect to varying inputs: ti ki
  SUBROUTINE BEAM_STIFFNESS_MATRIX_D(x1i, x2i, ri, ti, tid, e, ki, kid, &
&   li, ii, iid)
    IMPLICIT NONE
! Input variables
    REAL, INTENT(IN) :: x1i(3), x2i(3), ri, ti, e
    REAL, INTENT(IN) :: tid
! Output variables
    REAL, INTENT(OUT) :: ki(4, 4), li, ii
    REAL, INTENT(OUT) :: kid(4, 4), iid
! Working variables
    REAL :: kk
    REAL :: kkd
    REAL :: temp
! EXECUTION
! Compute the length of the beam
    li = x2i(2) - x1i(2)
! Compute the moment of inertia of a circular beam
    temp = ri*ri*ri
    iid = temp*pi*tid
    ii = temp*(pi*ti)
! Compute the bending term that is common to all elements
! of the stiffness matrix
    temp = li*li*li
    kkd = e*iid/temp
    kk = e*(ii/temp)
! Populate the stiffness matrix
    kid(1, 1) = 12*kkd
    ki(1, 1) = 12*kk
    kid(1, 2) = li*6*kkd
    ki(1, 2) = 6*li*kk
    kid(1, 3) = -(12*kkd)
    ki(1, 3) = -(12*kk)
    kid(1, 4) = li*6*kkd
    ki(1, 4) = 6*li*kk
    kid(2, 1) = li*6*kkd
    ki(2, 1) = 6*li*kk
    kid(2, 2) = li**2*4*kkd
    ki(2, 2) = 4*li**2*kk
    kid(2, 3) = -(li*6*kkd)
    ki(2, 3) = -(6*li*kk)
    kid(2, 4) = li**2*2*kkd
    ki(2, 4) = 2*li**2*kk
    kid(3, 1) = -(12*kkd)
    ki(3, 1) = -(12*kk)
    kid(3, 2) = -(li*6*kkd)
    ki(3, 2) = -(6*li*kk)
    kid(3, 3) = 12*kkd
    ki(3, 3) = 12*kk
    kid(3, 4) = -(li*6*kkd)
    ki(3, 4) = -(6*li*kk)
    kid(4, 1) = li*6*kkd
    ki(4, 1) = 6*li*kk
    kid(4, 2) = li**2*2*kkd
    ki(4, 2) = 2*li**2*kk
    kid(4, 3) = -(li*6*kkd)
    ki(4, 3) = -(6*li*kk)
    kid(4, 4) = li**2*4*kkd
    ki(4, 4) = 4*li**2*kk
  END SUBROUTINE BEAM_STIFFNESS_MATRIX_D

  SUBROUTINE BEAM_STIFFNESS_MATRIX(x1i, x2i, ri, ti, e, ki, li, ii)
    IMPLICIT NONE
! Input variables
    REAL, INTENT(IN) :: x1i(3), x2i(3), ri, ti, e
! Output variables
    REAL, INTENT(OUT) :: ki(4, 4), li, ii
! Working variables
    REAL :: kk
! EXECUTION
! Compute the length of the beam
    li = x2i(2) - x1i(2)
! Compute the moment of inertia of a circular beam
    ii = pi*ri**3*ti
! Compute the bending term that is common to all elements
! of the stiffness matrix
    kk = e*ii/li**3
! Populate the stiffness matrix
    ki(1, 1) = 12*kk
    ki(1, 2) = 6*li*kk
    ki(1, 3) = -(12*kk)
    ki(1, 4) = 6*li*kk
    ki(2, 1) = 6*li*kk
    ki(2, 2) = 4*li**2*kk
    ki(2, 3) = -(6*li*kk)
    ki(2, 4) = 2*li**2*kk
    ki(3, 1) = -(12*kk)
    ki(3, 2) = -(6*li*kk)
    ki(3, 3) = 12*kk
    ki(3, 4) = -(6*li*kk)
    ki(4, 1) = 6*li*kk
    ki(4, 2) = 2*li**2*kk
    ki(4, 3) = -(6*li*kk)
    ki(4, 4) = 4*li**2*kk
  END SUBROUTINE BEAM_STIFFNESS_MATRIX

!  Differentiation of get_k_matrix in forward (tangent) mode:
!   variations   of useful results: k
!   with respect to varying inputs: t
!============================================================
  SUBROUTINE GET_K_MATRIX_D(n_beams, x, r, t, td, e, k, kd, n_dofs)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_beams
    REAL, INTENT(IN) :: x(3, n_beams+1)
    REAL, INTENT(IN) :: r(n_beams), t(n_beams), e
    REAL, INTENT(IN) :: td(n_beams)
! Output variables
    REAL, INTENT(OUT) :: k(2*(n_beams+1), 2*(n_beams+1))
    REAL, INTENT(OUT) :: kd(2*(n_beams+1), 2*(n_beams+1))
    INTEGER, INTENT(OUT) :: n_dofs
! Working variables
    INTEGER :: jj
    REAL :: x1i(3), x2i(3), ki(4, 4), li, ii
    REAL :: kid(4, 4), iid
! EXECUTION
! Initialize the stifness matrix
    k = zero
    kd = 0.0
    kid = 0.0
! Loop over all beams
    DO jj=1,n_beams
! Get nodal coordinates of the current beam
      x1i = x(:, jj)
      x2i = x(:, jj+1)
! Compute the element stiffness matrix
      CALL BEAM_STIFFNESS_MATRIX_D(x1i, x2i, r(jj), t(jj), td(jj), e, ki&
&                            , kid, li, ii, iid)
! Assign the element matrix to the global matrix
      kd(2*jj-1:2*jj+2, 2*jj-1:2*jj+2) = kd(2*jj-1:2*jj+2, 2*jj-1:2*jj+2&
&       ) + kid
      k(2*jj-1:2*jj+2, 2*jj-1:2*jj+2) = k(2*jj-1:2*jj+2, 2*jj-1:2*jj+2) &
&       + ki
    END DO
! Compute number of degrees of freedom
    n_dofs = 2*(n_beams+1)
  END SUBROUTINE GET_K_MATRIX_D

!============================================================
  SUBROUTINE GET_K_MATRIX(n_beams, x, r, t, e, k, n_dofs)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_beams
    REAL, INTENT(IN) :: x(3, n_beams+1)
    REAL, INTENT(IN) :: r(n_beams), t(n_beams), e
! Output variables
    REAL, INTENT(OUT) :: k(2*(n_beams+1), 2*(n_beams+1))
    INTEGER, INTENT(OUT) :: n_dofs
! Working variables
    INTEGER :: jj
    REAL :: x1i(3), x2i(3), ki(4, 4), li, ii
! EXECUTION
! Initialize the stifness matrix
    k = zero
! Loop over all beams
    DO jj=1,n_beams
! Get nodal coordinates of the current beam
      x1i = x(:, jj)
      x2i = x(:, jj+1)
! Compute the element stiffness matrix
      CALL BEAM_STIFFNESS_MATRIX(x1i, x2i, r(jj), t(jj), e, ki, li, ii)
! Assign the element matrix to the global matrix
      k(2*jj-1:2*jj+2, 2*jj-1:2*jj+2) = k(2*jj-1:2*jj+2, 2*jj-1:2*jj+2) &
&       + ki
    END DO
! Compute number of degrees of freedom
    n_dofs = 2*(n_beams+1)
  END SUBROUTINE GET_K_MATRIX

!  Differentiation of apply_cons in forward (tangent) mode:
!   variations   of useful results: f k
!   with respect to varying inputs: f k
!============================================================
  SUBROUTINE APPLY_CONS_D(n_dofs, n_cons, conids, k, kd, f, fd)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_dofs, n_cons
    INTEGER, INTENT(IN) :: conids(n_cons)
! Output variables
    REAL, INTENT(INOUT) :: k(n_dofs, n_dofs)
    REAL, INTENT(INOUT) :: kd(n_dofs, n_dofs)
    REAL, INTENT(INOUT) :: f(n_dofs)
    REAL, INTENT(INOUT) :: fd(n_dofs)
! Working variables
    INTEGER :: ii, curr_con
! EXECUTION
! First we will create the array freeIDs containing all indices
! of the free DOFs. Then we will use this array to crop Kf and ff.
! Now we set the indices of the constrained DOFs to zero
    DO ii=1,n_cons
      curr_con = conids(ii)
! We will modify K and f so that d(curr_con) is forced to be zero.
! We can do that by setting:
! f(curr_con)=0, K(curr_con,:)=0, K(:,curr_con)=1,
! and K(curr_con,curr_con)=1.
! Modify the K matrix
      kd(curr_con, :) = 0.0
      k(curr_con, :) = 0.0
      kd(:, curr_con) = 0.0
      k(:, curr_con) = 0.0
      kd(curr_con, curr_con) = 0.0
      k(curr_con, curr_con) = 1.0
! Modify the f vector
      fd(curr_con) = 0.0
      f(curr_con) = 0.0
    END DO
  END SUBROUTINE APPLY_CONS_D

!============================================================
  SUBROUTINE APPLY_CONS(n_dofs, n_cons, conids, k, f)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_dofs, n_cons
    INTEGER, INTENT(IN) :: conids(n_cons)
! Output variables
    REAL, INTENT(INOUT) :: k(n_dofs, n_dofs)
    REAL, INTENT(INOUT) :: f(n_dofs)
! Working variables
    INTEGER :: ii, curr_con
! EXECUTION
! First we will create the array freeIDs containing all indices
! of the free DOFs. Then we will use this array to crop Kf and ff.
! Now we set the indices of the constrained DOFs to zero
    DO ii=1,n_cons
      curr_con = conids(ii)
! We will modify K and f so that d(curr_con) is forced to be zero.
! We can do that by setting:
! f(curr_con)=0, K(curr_con,:)=0, K(:,curr_con)=1,
! and K(curr_con,curr_con)=1.
! Modify the K matrix
      k(curr_con, :) = 0.0
      k(:, curr_con) = 0.0
      k(curr_con, curr_con) = 1.0
! Modify the f vector
      f(curr_con) = 0.0
    END DO
  END SUBROUTINE APPLY_CONS

!  Differentiation of get_residuals in forward (tangent) mode:
!   variations   of useful results: res
!   with respect to varying inputs: d f t
!============================================================
  SUBROUTINE GET_RESIDUALS_D0(n_beams, n_cons, x, r, t, td, f, fd, d, dd&
&   , e, conids, res, resd)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_beams, n_cons
    REAL, INTENT(IN) :: x(3, n_beams+1)
    REAL, INTENT(IN) :: r(n_beams), t(n_beams)
    REAL, INTENT(IN) :: td(n_beams)
    REAL, INTENT(IN) :: f(2*(n_beams+1)), d(2*(n_beams+1)), e
    REAL, INTENT(IN) :: fd(2*(n_beams+1)), dd(2*(n_beams+1))
    INTEGER, INTENT(IN) :: conids(n_cons)
! Output variables
    REAL, INTENT(OUT) :: res(2*(n_beams+1))
    REAL, INTENT(OUT) :: resd(2*(n_beams+1))
! Working variables
    REAL :: k(2*(n_beams+1), 2*(n_beams+1)), fcopy(2*(n_beams+1))
    REAL :: kd0(2*(n_beams+1), 2*(n_beams+1)), fcopyd(2*(n_beams+1))
    REAL :: kd(2*(n_beams+1))
    REAL :: kdd(2*(n_beams+1))
    INTEGER :: n_dofs
! EXECUTION
! Build the full stiffness matrix
    CALL GET_K_MATRIX_D(n_beams, x, r, t, td, e, k, kd0, n_dofs)
! Make a copy of the force vector so we can modify its elements
    fcopyd = fd
    fcopy = f
! Apply the constraints
    CALL APPLY_CONS_D(n_dofs, n_cons, conids, k, kd0, fcopy, fcopyd)
! Compute K*d
    CALL MATDOTVEC_D(n_dofs, k, kd0, d, dd, kd, kdd)
! Compute the residuals
    resd = kdd - fcopyd
    res = kd - fcopy
  END SUBROUTINE GET_RESIDUALS_D0

!============================================================
  SUBROUTINE GET_RESIDUALS(n_beams, n_cons, x, r, t, f, d, e, conids, &
&   res)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_beams, n_cons
    REAL, INTENT(IN) :: x(3, n_beams+1)
    REAL, INTENT(IN) :: r(n_beams), t(n_beams)
    REAL, INTENT(IN) :: f(2*(n_beams+1)), d(2*(n_beams+1)), e
    INTEGER, INTENT(IN) :: conids(n_cons)
! Output variables
    REAL, INTENT(OUT) :: res(2*(n_beams+1))
! Working variables
    REAL :: k(2*(n_beams+1), 2*(n_beams+1)), fcopy(2*(n_beams+1))
    REAL :: kd(2*(n_beams+1))
    INTEGER :: n_dofs
! EXECUTION
! Build the full stiffness matrix
    CALL GET_K_MATRIX(n_beams, x, r, t, e, k, n_dofs)
! Make a copy of the force vector so we can modify its elements
    fcopy = f
! Apply the constraints
    CALL APPLY_CONS(n_dofs, n_cons, conids, k, fcopy)
! Compute K*d
    CALL MATDOTVEC(n_dofs, k, d, kd)
! Compute the residuals
    res = kd - fcopy
  END SUBROUTINE GET_RESIDUALS

!  Differentiation of get_functions in forward (tangent) mode:
!   variations   of useful results: mass ksmargin margins
!   with respect to varying inputs: d t
!============================================================
  SUBROUTINE GET_FUNCTIONS_D0(n_beams, n_cons, x, r, t, td, f, d, dd, e&
&   , rho, sigmay, pks, conids, mass, massd, margins, marginsd, ksmargin&
&   , ksmargind)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_beams, n_cons
    REAL, INTENT(IN) :: x(3, n_beams+1)
    REAL, INTENT(IN) :: r(n_beams), t(n_beams)
    REAL, INTENT(IN) :: td(n_beams)
    REAL, INTENT(IN) :: f(2*(n_beams+1)), d(2*(n_beams+1))
    REAL, INTENT(IN) :: dd(2*(n_beams+1))
    REAL, INTENT(IN) :: e, rho, sigmay, pks
    INTEGER, INTENT(IN) :: conids(n_cons)
! Output variables
    REAL, INTENT(OUT) :: mass, margins(2*n_beams), ksmargin
    REAL, INTENT(OUT) :: massd, marginsd(2*n_beams), ksmargind
! Working variables
    REAL :: k(2*(n_beams+1), 2*(n_beams+1)), fcopy(2*(n_beams+1))
    REAL :: kd(2*(n_beams+1))
    REAL :: x1i(3), x2i(3), ki(4, 4), li, ii, di(4), fi(4), ai
    REAL :: kid(4, 4), iid, did(4), fid(4), aid
    REAL :: sigma1, sigma2, tau, sigma_vm1, sigma_vm2
    REAL :: sigma1d, sigma2d, taud, sigma_vm1d, sigma_vm2d
    REAL :: margin_min, margin_sum
    REAL :: margin_sumd
    INTEGER :: n_dofs, jj
    INTRINSIC SQRT
    INTRINSIC EXP
    INTRINSIC SUM
    INTRINSIC LOG
    REAL :: arg1
    REAL :: arg1d
    REAL, DIMENSION(2*n_beams) :: arg10
    REAL, DIMENSION(2*n_beams) :: arg10d
    REAL, DIMENSION(2*n_beams) :: arg2
    REAL, DIMENSION(2*n_beams) :: arg2d
    REAL :: temp
! EXECUTION
! Initialize the mass value
    mass = 0
    massd = 0.0
    marginsd = 0.0
    kid = 0.0
! Loop over every element to compute contributions of mass and stress
    DO jj=1,n_beams
! Get nodal coordinates of the current beam
      x1i = x(:, jj)
      x2i = x(:, jj+1)
! Get element properties
      CALL BEAM_STIFFNESS_MATRIX_D(x1i, x2i, r(jj), t(jj), td(jj), e, ki&
&                            , kid, li, ii, iid)
! Compute section area
      aid = pi*2.0*r(jj)*td(jj)
      ai = 2.0*pi*r(jj)*t(jj)
! Compute mass contribution
      massd = massd + rho*li*aid
      mass = mass + rho*ai*li
! Get DOF values of the current nodes
      did = dd(2*jj-1:2*jj+2)
      di = d(2*jj-1:2*jj+2)
! Compute corresponding local nodal forces
      CALL MATDOTVEC_D(4, ki, kid, di, did, fi, fid)
! Compute bending stress on node 1 (sigma = M*y/I)
      temp = fi(2)/ii
      sigma1d = r(jj)*(fid(2)-temp*iid)/ii
      sigma1 = r(jj)*temp
! Compute bending stress on node 2 (sigma = M*y/I)
      temp = fi(4)/ii
      sigma2d = r(jj)*(fid(4)-temp*iid)/ii
      sigma2 = r(jj)*temp
! Compute shear stress on the beam (it is constant)
! We need 2.0 because shear is maximum at the midplane
      temp = fi(1)/ai
      taud = 2.0*(fid(1)-temp*aid)/ai
      tau = 2.0*temp
! Compute the Von Mises stress for each node
! This is a conservative measure, since we are using the
! maximum bending stress and the maximum shear stress, even though
! they are at different locations of the cross-section.
      arg1d = 2*sigma1*sigma1d + 3.0*2*tau*taud
      arg1 = sigma1**2 + 3.0*tau**2
      temp = SQRT(arg1)
      IF (arg1 .EQ. 0.0) THEN
        sigma_vm1d = 0.0
      ELSE
        sigma_vm1d = arg1d/(2.0*temp)
      END IF
      sigma_vm1 = temp
      arg1d = 2*sigma2*sigma2d + 3.0*2*tau*taud
      arg1 = sigma2**2 + 3.0*tau**2
      temp = SQRT(arg1)
      IF (arg1 .EQ. 0.0) THEN
        sigma_vm2d = 0.0
      ELSE
        sigma_vm2d = arg1d/(2.0*temp)
      END IF
      sigma_vm2 = temp
! Compute the safety margin with respect to the failure
      marginsd(2*jj-1) = -(sigma_vm1d/sigmay)
      margins(2*jj-1) = 1.0 - sigma_vm1/sigmay
      marginsd(2*jj) = -(sigma_vm2d/sigmay)
      margins(2*jj) = 1.0 - sigma_vm2/sigmay
    END DO
! The KS function estimates the maximum value from the set.
! But the minimum margin is the most critical one.
! So we flip the sign of the margins to
! compute the KS value.
! Find the minimum safety margin (most critical case)
! NOTE: I deactivated this since the changes in the minimum values
! caused discrepancies with respect to the finite difference test
! when checking derivatives.
!1.0
    margin_min = 0.0
!do jj=1,2*n_beams
!   margin_min = min(margin_min, margins(jj))
!end do
! Compute sum of the KS expression inside the natural logarithm.
! Note that we flipped the margins signs.
    arg10d(:) = -(pks*marginsd)
    arg10(:) = pks*(-margins+margin_min)
    arg2d(:) = EXP(arg10(:))*arg10d(:)
    arg2(:) = EXP(arg10(:))
    margin_sumd = SUM(arg2d(:))
    margin_sum = SUM(arg2(:))
! Aggregate stresses
    ksmargind = -(margin_sumd/(pks*margin_sum))
    ksmargin = margin_min - 1.0/pks*LOG(margin_sum)
  END SUBROUTINE GET_FUNCTIONS_D0

!============================================================
  SUBROUTINE GET_FUNCTIONS(n_beams, n_cons, x, r, t, f, d, e, rho, &
&   sigmay, pks, conids, mass, margins, ksmargin)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_beams, n_cons
    REAL, INTENT(IN) :: x(3, n_beams+1)
    REAL, INTENT(IN) :: r(n_beams), t(n_beams)
    REAL, INTENT(IN) :: f(2*(n_beams+1)), d(2*(n_beams+1))
    REAL, INTENT(IN) :: e, rho, sigmay, pks
    INTEGER, INTENT(IN) :: conids(n_cons)
! Output variables
    REAL, INTENT(OUT) :: mass, margins(2*n_beams), ksmargin
! Working variables
    REAL :: k(2*(n_beams+1), 2*(n_beams+1)), fcopy(2*(n_beams+1))
    REAL :: kd(2*(n_beams+1))
    REAL :: x1i(3), x2i(3), ki(4, 4), li, ii, di(4), fi(4), ai
    REAL :: sigma1, sigma2, tau, sigma_vm1, sigma_vm2
    REAL :: margin_min, margin_sum
    INTEGER :: n_dofs, jj
    INTRINSIC SQRT
    INTRINSIC EXP
    INTRINSIC SUM
    INTRINSIC LOG
    REAL :: arg1
    REAL, DIMENSION(2*n_beams) :: arg10
    REAL, DIMENSION(2*n_beams) :: arg2
! EXECUTION
! Initialize the mass value
    mass = 0
! Loop over every element to compute contributions of mass and stress
    DO jj=1,n_beams
! Get nodal coordinates of the current beam
      x1i = x(:, jj)
      x2i = x(:, jj+1)
! Get element properties
      CALL BEAM_STIFFNESS_MATRIX(x1i, x2i, r(jj), t(jj), e, ki, li, ii)
! Compute section area
      ai = 2.0*pi*r(jj)*t(jj)
! Compute mass contribution
      mass = mass + rho*ai*li
! Get DOF values of the current nodes
      di = d(2*jj-1:2*jj+2)
! Compute corresponding local nodal forces
      CALL MATDOTVEC(4, ki, di, fi)
! Compute bending stress on node 1 (sigma = M*y/I)
      sigma1 = fi(2)*r(jj)/ii
! Compute bending stress on node 2 (sigma = M*y/I)
      sigma2 = fi(4)*r(jj)/ii
! Compute shear stress on the beam (it is constant)
! We need 2.0 because shear is maximum at the midplane
      tau = 2.0*fi(1)/ai
! Compute the Von Mises stress for each node
! This is a conservative measure, since we are using the
! maximum bending stress and the maximum shear stress, even though
! they are at different locations of the cross-section.
      arg1 = sigma1**2 + 3.0*tau**2
      sigma_vm1 = SQRT(arg1)
      arg1 = sigma2**2 + 3.0*tau**2
      sigma_vm2 = SQRT(arg1)
! Compute the safety margin with respect to the failure
      margins(2*jj-1) = 1.0 - sigma_vm1/sigmay
      margins(2*jj) = 1.0 - sigma_vm2/sigmay
    END DO
! The KS function estimates the maximum value from the set.
! But the minimum margin is the most critical one.
! So we flip the sign of the margins to
! compute the KS value.
! Find the minimum safety margin (most critical case)
! NOTE: I deactivated this since the changes in the minimum values
! caused discrepancies with respect to the finite difference test
! when checking derivatives.
!1.0
    margin_min = 0.0
!do jj=1,2*n_beams
!   margin_min = min(margin_min, margins(jj))
!end do
! Compute sum of the KS expression inside the natural logarithm.
! Note that we flipped the margins signs.
    arg10(:) = pks*(-margins+margin_min)
    arg2(:) = EXP(arg10(:))
    margin_sum = SUM(arg2(:))
! Aggregate stresses
    ksmargin = margin_min - 1.0/pks*LOG(margin_sum)
  END SUBROUTINE GET_FUNCTIONS

!  Differentiation of matdotvec in forward (tangent) mode:
!   variations   of useful results: kd
!   with respect to varying inputs: d k
!============================================================
  SUBROUTINE MATDOTVEC_D(n, k, kd0, d, dd, kd, kdd)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n
    REAL, INTENT(IN) :: k(n, n), d(n)
    REAL, INTENT(IN) :: kd0(n, n), dd(n)
! Output variables
    REAL, INTENT(OUT) :: kd(n)
    REAL, INTENT(OUT) :: kdd(n)
! Working variables
    INTEGER :: ii
! EXECUTION
    kd = 0.0
    kdd = 0.0
    DO ii=1,n
      kdd = kdd + d(ii)*kd0(:, ii) + k(:, ii)*dd(ii)
      kd = kd + k(:, ii)*d(ii)
    END DO
  END SUBROUTINE MATDOTVEC_D

!============================================================
  SUBROUTINE MATDOTVEC(n, k, d, kd)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n
    REAL, INTENT(IN) :: k(n, n), d(n)
! Output variables
    REAL, INTENT(OUT) :: kd(n)
! Working variables
    INTEGER :: ii
! EXECUTION
    kd = 0.0
    DO ii=1,n
      kd = kd + k(:, ii)*d(ii)
    END DO
  END SUBROUTINE MATDOTVEC

!  Differentiation of fem_main in forward (tangent) mode:
!   variations   of useful results: res mass ksmargin margins
!   with respect to varying inputs: d f t
!============================================================
  SUBROUTINE FEM_MAIN_D(n_beams, n_cons, x, r, t, td, f, fd, d, dd, e, &
&   rho, sigmay, pks, conids, res, resd, mass, massd, margins, marginsd&
&   , ksmargin, ksmargind)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_beams, n_cons
    REAL, INTENT(IN) :: x(3, n_beams+1)
    REAL, INTENT(IN) :: r(n_beams), t(n_beams)
    REAL, INTENT(IN) :: td(n_beams)
    REAL, INTENT(IN) :: f(2*(n_beams+1)), d(2*(n_beams+1))
    REAL, INTENT(IN) :: fd(2*(n_beams+1)), dd(2*(n_beams+1))
    REAL, INTENT(IN) :: e, rho, sigmay, pks
    INTEGER, INTENT(IN) :: conids(n_cons)
! Output variables
    REAL, INTENT(OUT) :: res(2*(n_beams+1)), mass, margins(2*n_beams), &
&   ksmargin
    REAL, INTENT(OUT) :: resd(2*(n_beams+1)), massd, marginsd(2*n_beams)&
&   , ksmargind
! EXECUTION
! Call relevant subroutines
    CALL GET_RESIDUALS_D0(n_beams, n_cons, x, r, t, td, f, fd, d, dd, e&
&                   , conids, res, resd)
    CALL GET_FUNCTIONS_D0(n_beams, n_cons, x, r, t, td, f, d, dd, e, rho&
&                   , sigmay, pks, conids, mass, massd, margins, &
&                   marginsd, ksmargin, ksmargind)
  END SUBROUTINE FEM_MAIN_D

!============================================================
  SUBROUTINE FEM_MAIN(n_beams, n_cons, x, r, t, f, d, e, rho, sigmay, &
&   pks, conids, res, mass, margins, ksmargin)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_beams, n_cons
    REAL, INTENT(IN) :: x(3, n_beams+1)
    REAL, INTENT(IN) :: r(n_beams), t(n_beams)
    REAL, INTENT(IN) :: f(2*(n_beams+1)), d(2*(n_beams+1))
    REAL, INTENT(IN) :: e, rho, sigmay, pks
    INTEGER, INTENT(IN) :: conids(n_cons)
! Output variables
    REAL, INTENT(OUT) :: res(2*(n_beams+1)), mass, margins(2*n_beams), &
&   ksmargin
! EXECUTION
! Call relevant subroutines
    CALL GET_RESIDUALS(n_beams, n_cons, x, r, t, f, d, e, conids, res)
    CALL GET_FUNCTIONS(n_beams, n_cons, x, r, t, f, d, e, rho, sigmay, &
&                pks, conids, mass, margins, ksmargin)
  END SUBROUTINE FEM_MAIN

END MODULE FEM_MODULE_D

