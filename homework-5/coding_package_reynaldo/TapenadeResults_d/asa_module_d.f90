!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.15 (master) - 15 Apr 2020 11:54
!
MODULE ASA_MODULE_D
  IMPLICIT NONE
  REAL, PARAMETER :: zero=0.0
  REAL, PARAMETER :: pi=3.1415926535897932384626
  REAL, PARAMETER :: eps=EPSILON(zero)

CONTAINS
!  Differentiation of transfer_disps in forward (tangent) mode:
!   variations   of useful results: xllt
!   with respect to varying inputs: d
  SUBROUTINE TRANSFER_DISPS_D(n_nodes, xfem, d, dd, xllt, xlltd)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_nodes
    REAL, INTENT(IN) :: xfem(3, n_nodes), d(2*n_nodes)
    REAL, INTENT(IN) :: dd(2*n_nodes)
! Output variables
    REAL, INTENT(OUT) :: xllt(3, n_nodes)
    REAL, INTENT(OUT) :: xlltd(3, n_nodes)
! EXECUTION
! Copy Xfem to Xllt, but just apply displacements in the z direction
    xllt(1, :) = xfem(1, :)
    xllt(2, :) = xfem(2, :)
    xlltd = 0.0
    xlltd(3, :) = dd(::2)
    xllt(3, :) = xfem(3, :) + d(::2)
  END SUBROUTINE TRANSFER_DISPS_D

  SUBROUTINE TRANSFER_DISPS(n_nodes, xfem, d, xllt)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_nodes
    REAL, INTENT(IN) :: xfem(3, n_nodes), d(2*n_nodes)
! Output variables
    REAL, INTENT(OUT) :: xllt(3, n_nodes)
! EXECUTION
! Copy Xfem to Xllt, but just apply displacements in the z direction
    xllt(1, :) = xfem(1, :)
    xllt(2, :) = xfem(2, :)
    xllt(3, :) = xfem(3, :) + d(::2)
  END SUBROUTINE TRANSFER_DISPS

!  Differentiation of transfer_forces in forward (tangent) mode:
!   variations   of useful results: f
!   with respect to varying inputs: loads
!============================================================
  SUBROUTINE TRANSFER_FORCES_D(n_nodes, xfem, loads, loadsd, f, fd)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_nodes
    REAL, INTENT(IN) :: xfem(3, n_nodes), loads(n_nodes-1)
    REAL, INTENT(IN) :: loadsd(n_nodes-1)
! Output variables
    REAL, INTENT(OUT) :: f(2*n_nodes)
    REAL, INTENT(OUT) :: fd(2*n_nodes)
! Working variables
    REAL :: l(n_nodes-1)
    INTEGER :: ii
! EXECUTION
! Compute the panel lengths along the span axis (y-dim)
    l = xfem(2, 2:n_nodes) - xfem(2, 1:n_nodes-1)
! Initialize consistent force vector
    f = zero
    fd = 0.0
! Compute contributions of each horseshoe vortex to the consistent forces
    DO ii=1,n_nodes-1
      fd(2*ii-1) = fd(2*ii-1) + loadsd(ii)/2
      f(2*ii-1) = f(2*ii-1) + loads(ii)/2
      fd(2*ii) = fd(2*ii) + l(ii)*loadsd(ii)/12
      f(2*ii) = f(2*ii) + loads(ii)*l(ii)/12
      fd(2*ii+1) = fd(2*ii+1) + loadsd(ii)/2
      f(2*ii+1) = f(2*ii+1) + loads(ii)/2
      fd(2*ii+2) = fd(2*ii+2) - l(ii)*loadsd(ii)/12
      f(2*ii+2) = f(2*ii+2) - loads(ii)*l(ii)/12
    END DO
  END SUBROUTINE TRANSFER_FORCES_D

!============================================================
  SUBROUTINE TRANSFER_FORCES(n_nodes, xfem, loads, f)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_nodes
    REAL, INTENT(IN) :: xfem(3, n_nodes), loads(n_nodes-1)
! Output variables
    REAL, INTENT(OUT) :: f(2*n_nodes)
! Working variables
    REAL :: l(n_nodes-1)
    INTEGER :: ii
! EXECUTION
! Compute the panel lengths along the span axis (y-dim)
    l = xfem(2, 2:n_nodes) - xfem(2, 1:n_nodes-1)
! Initialize consistent force vector
    f = zero
! Compute contributions of each horseshoe vortex to the consistent forces
    DO ii=1,n_nodes-1
      f(2*ii-1) = f(2*ii-1) + loads(ii)/2
      f(2*ii) = f(2*ii) + loads(ii)*l(ii)/12
      f(2*ii+1) = f(2*ii+1) + loads(ii)/2
      f(2*ii+2) = f(2*ii+2) - loads(ii)*l(ii)/12
    END DO
  END SUBROUTINE TRANSFER_FORCES

!  Differentiation of asa_analysis in forward (tangent) mode:
!   variations   of useful results: liftexcess ksmargin resllt
!                fb margins resfem weight
!   with respect to varying inputs: d alpha0 t gama
!   RW status of diff variables: liftexcess:out d:in alpha0:in
!                t:in ksmargin:out resllt:out fb:out margins:out
!                resfem:out gama:in weight:out
!============================================================
  SUBROUTINE ASA_ANALYSIS_D(n_panels, n_cons, gama, gamad, alpha0, &
&   alpha0d, chords, xfem, r, t, td, d, dd, cl0, cla, vinf, rhoair, e, &
&   rhomat, sigmay, pks, conids, cd0, fixedmass, g, endurance, tsfc, &
&   loadfactor, resllt, reslltd, resfem, resfemd, liftexcess, &
&   liftexcessd, margins, marginsd, ksmargin, ksmargind, fb, fbd, weight&
&   , weightd, sref, cl)
! This subroutine computes the residuals of the coupled aerostructural
! problem.
!
! INPUTS
!
! n_panels: integer -> Number of horseshoe panels and beams (the same).
! n_cons: integer -> Number of constrained DOFs.
! Gama: real(n_panels) -> Circulation intensity of each horseshoe vortex.
! alpha0: real(n_panels) -> Array of local incidence angles.
! chords: real(n_panels) -> Array of local chords.
! Xfem: real(3,n_panels+1) -> Coordinates of the undeformed beam nodes.
! r: real(n_panels) -> Radius of each beam element.
! t: real(n_panels) -> Wall thickness of each beam element.
! d: real(2*(n_panels+1)) -> Displacements values of all DOFs (including
!                           the constrained ones).
! cl0: real(n_panels) -> cl0 of each 2D section
! cla: real(n_panels) -> lift curve slope of each 2D section [1/rad]
! Vinf: real(3) -> Free-stream velocity vector
! rhoAir: real -> Air density
! E: real -> Young's module of the beam material.
! rhoMat: real -> Density of the beam material.
! sigmaY: real -> Yield stress of the beam material.
! pKS: real -> Constant of the KS functons used to aggregate stresses.
! conIDs: integer(n_cons) -> Indices of the DOFs of the Kf matrix that
!                            should be constrained.
! CD0: real -> Parasite drag that will be added to the induced drag.
! fixedMass: real -> Fixed mass of the aircraft less the wing structure.
! g: real -> Acceleration of gravity.
! Endurance: real -> Desired endurance of the aircraft.
! TSFC: real -> Thrust specific fuel consumption of the engine.
! loadFactor: real -> Factor applied to the structural failure margin
!                     to consider a multiplicative factor in the loads.
!
! OUTPUTS
!
! resllt: real(n_panels) -> Residuals of the LLT method
! resfem: real(2*(n_panels+1)) -> Residuals of the FEM model
!                                 considering all DOFs (including the
!                                 constrained ones). The residuals
!                                 of the constrained DOFs are the
!                                 displacements themselves, so that the
!                                 solver drives them to zero. We
!                                 modify the K matrix in appy_cons to
!                                 achieve that.
! liftExcess: real -> Difference between the generated lift and the.
!                     aircraft weight. This value is normalized:
!                     liftExcess = Lift/Weigth - 1
! margins: real(2*n_panels) -> Margin from Von Mises stress at each node
!                              with respect to the yield stress.
!                              The margins are computed as:
!                              margin = 1.0 - sigma_vm/sigmaY
!                              Negative margins indicate failure.
!                              Internal nodes have two values
!                              corresponding to the beam sections on
!                              either side. KSmargin is the aggregation of
!                              these values.
! KSmargin: real -> Aggregated safety margin. This value
!                   is a conservative estimate of the minimum
!                   margin value in the structure. This estimate
!                   gets closer to the real value as we increase
!                   pKS, but this may lead to numerical issues.
! FB: real -> Fuel burn (in Force units).
! Weight: real -> Total weight of the aircraft (in Force units)
!                 (fixed weight + structure weight + fuel weight)
! Sref: real -> Area of all panels
! CL: real -> Lift coefficient (adimensionalized by Sref)
    USE LLT_MODULE_D, ONLY : tapenade_main, tapenade_main_d
    USE FEM_MODULE_D, ONLY : fem_main, fem_main_d
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_panels, n_cons
    REAL, INTENT(IN) :: gama(n_panels), alpha0(n_panels)
    REAL, INTENT(IN) :: gamad(n_panels), alpha0d(n_panels)
    REAL, INTENT(IN) :: chords(n_panels)
    REAL, INTENT(IN) :: xfem(3, n_panels+1)
    REAL, INTENT(IN) :: r(n_panels), t(n_panels)
    REAL, INTENT(IN) :: td(n_panels)
    REAL, INTENT(IN) :: d(2*(n_panels+1))
    REAL, INTENT(IN) :: dd(2*(n_panels+1))
    REAL, INTENT(IN) :: cl0(n_panels), cla(n_panels), vinf(3), rhoair
    REAL, INTENT(IN) :: e, rhomat, sigmay, pks
    INTEGER, INTENT(IN) :: conids(n_cons)
    REAL, INTENT(IN) :: cd0, fixedmass, g, endurance, tsfc, loadfactor
! Output variables
    REAL, INTENT(OUT) :: resllt(n_panels), resfem(2*(n_panels+1))
    REAL, INTENT(OUT) :: reslltd(n_panels), resfemd(2*(n_panels+1))
    REAL, INTENT(OUT) :: liftexcess, margins(2*n_panels)
    REAL, INTENT(OUT) :: liftexcessd, marginsd(2*n_panels)
    REAL, INTENT(OUT) :: ksmargin, fb, weight, sref, cl
    REAL, INTENT(OUT) :: ksmargind, fbd, weightd
! Working variables
    REAL :: xllt(3, n_panels+1)
    REAL :: xlltd(3, n_panels+1)
    REAL :: loads(n_panels), f(2*(n_panels+1))
    REAL :: loadsd(n_panels), fd(2*(n_panels+1))
    REAL :: cd, l, di, structuremass, drag, aux
    REAL :: ld, did, structuremassd, dragd, auxd
    INTRINSIC SUM
    INTRINSIC EXP
    REAL :: arg1
    REAL :: arg1d
    REAL :: temp
    REAL :: srefd
! EXECUTION
    CALL TRANSFER_DISPS_D(n_panels + 1, xfem, d, dd, xllt, xlltd)
    CALL TAPENADE_MAIN_D(n_panels, xllt, xlltd, gama, gamad, alpha0, &
&                  alpha0d, chords, cl0, cla, vinf, rhoair, resllt, &
&                  reslltd, sref, srefd, cl, cd, l, ld, di, did, loads, &
&                  loadsd)
    CALL TRANSFER_FORCES_D(n_panels + 1, xfem, loads, loadsd, f, fd)
    CALL FEM_MAIN_D(n_panels, n_cons, xfem, r, t, td, f, fd, d, dd, e, &
&             rhomat, sigmay, pks, conids, resfem, resfemd, &
&             structuremass, structuremassd, margins, marginsd, ksmargin&
&             , ksmargind)
    marginsd = loadfactor*marginsd
    margins = loadfactor*margins + 1 - loadfactor
    ksmargind = loadfactor*ksmargind
    ksmargin = ksmargin*loadfactor + 1 - loadfactor
    temp = SUM(vinf*vinf)
    dragd = did + temp*rhoair*cd0*srefd/2
    drag = di + temp*(rhoair*cd0*(sref/2))
    arg1d = endurance*tsfc*(dragd-drag*ld/l)/l
    arg1 = endurance*tsfc*drag/l
    auxd = EXP(arg1)*arg1d
    aux = EXP(arg1)
    fbd = g*((aux-1)*structuremassd+(fixedmass+structuremass)*auxd)
    fb = g*(fixedmass+structuremass)*(aux-1)
    weightd = g*structuremassd + fbd
    weight = g*(fixedmass+structuremass) + fb
    liftexcessd = (ld-l*weightd/weight)/weight
    liftexcess = l/weight - 1
  END SUBROUTINE ASA_ANALYSIS_D

!============================================================
  SUBROUTINE ASA_ANALYSIS(n_panels, n_cons, gama, alpha0, chords, xfem, &
&   r, t, d, cl0, cla, vinf, rhoair, e, rhomat, sigmay, pks, conids, cd0&
&   , fixedmass, g, endurance, tsfc, loadfactor, resllt, resfem, &
&   liftexcess, margins, ksmargin, fb, weight, sref, cl)
! This subroutine computes the residuals of the coupled aerostructural
! problem.
!
! INPUTS
!
! n_panels: integer -> Number of horseshoe panels and beams (the same).
! n_cons: integer -> Number of constrained DOFs.
! Gama: real(n_panels) -> Circulation intensity of each horseshoe vortex.
! alpha0: real(n_panels) -> Array of local incidence angles.
! chords: real(n_panels) -> Array of local chords.
! Xfem: real(3,n_panels+1) -> Coordinates of the undeformed beam nodes.
! r: real(n_panels) -> Radius of each beam element.
! t: real(n_panels) -> Wall thickness of each beam element.
! d: real(2*(n_panels+1)) -> Displacements values of all DOFs (including
!                           the constrained ones).
! cl0: real(n_panels) -> cl0 of each 2D section
! cla: real(n_panels) -> lift curve slope of each 2D section [1/rad]
! Vinf: real(3) -> Free-stream velocity vector
! rhoAir: real -> Air density
! E: real -> Young's module of the beam material.
! rhoMat: real -> Density of the beam material.
! sigmaY: real -> Yield stress of the beam material.
! pKS: real -> Constant of the KS functons used to aggregate stresses.
! conIDs: integer(n_cons) -> Indices of the DOFs of the Kf matrix that
!                            should be constrained.
! CD0: real -> Parasite drag that will be added to the induced drag.
! fixedMass: real -> Fixed mass of the aircraft less the wing structure.
! g: real -> Acceleration of gravity.
! Endurance: real -> Desired endurance of the aircraft.
! TSFC: real -> Thrust specific fuel consumption of the engine.
! loadFactor: real -> Factor applied to the structural failure margin
!                     to consider a multiplicative factor in the loads.
!
! OUTPUTS
!
! resllt: real(n_panels) -> Residuals of the LLT method
! resfem: real(2*(n_panels+1)) -> Residuals of the FEM model
!                                 considering all DOFs (including the
!                                 constrained ones). The residuals
!                                 of the constrained DOFs are the
!                                 displacements themselves, so that the
!                                 solver drives them to zero. We
!                                 modify the K matrix in appy_cons to
!                                 achieve that.
! liftExcess: real -> Difference between the generated lift and the.
!                     aircraft weight. This value is normalized:
!                     liftExcess = Lift/Weigth - 1
! margins: real(2*n_panels) -> Margin from Von Mises stress at each node
!                              with respect to the yield stress.
!                              The margins are computed as:
!                              margin = 1.0 - sigma_vm/sigmaY
!                              Negative margins indicate failure.
!                              Internal nodes have two values
!                              corresponding to the beam sections on
!                              either side. KSmargin is the aggregation of
!                              these values.
! KSmargin: real -> Aggregated safety margin. This value
!                   is a conservative estimate of the minimum
!                   margin value in the structure. This estimate
!                   gets closer to the real value as we increase
!                   pKS, but this may lead to numerical issues.
! FB: real -> Fuel burn (in Force units).
! Weight: real -> Total weight of the aircraft (in Force units)
!                 (fixed weight + structure weight + fuel weight)
! Sref: real -> Area of all panels
! CL: real -> Lift coefficient (adimensionalized by Sref)
    USE LLT_MODULE_D, ONLY : tapenade_main
    USE FEM_MODULE_D, ONLY : fem_main
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_panels, n_cons
    REAL, INTENT(IN) :: gama(n_panels), alpha0(n_panels)
    REAL, INTENT(IN) :: chords(n_panels)
    REAL, INTENT(IN) :: xfem(3, n_panels+1)
    REAL, INTENT(IN) :: r(n_panels), t(n_panels)
    REAL, INTENT(IN) :: d(2*(n_panels+1))
    REAL, INTENT(IN) :: cl0(n_panels), cla(n_panels), vinf(3), rhoair
    REAL, INTENT(IN) :: e, rhomat, sigmay, pks
    INTEGER, INTENT(IN) :: conids(n_cons)
    REAL, INTENT(IN) :: cd0, fixedmass, g, endurance, tsfc, loadfactor
! Output variables
    REAL, INTENT(OUT) :: resllt(n_panels), resfem(2*(n_panels+1))
    REAL, INTENT(OUT) :: liftexcess, margins(2*n_panels)
    REAL, INTENT(OUT) :: ksmargin, fb, weight, sref, cl
! Working variables
    REAL :: xllt(3, n_panels+1)
    REAL :: loads(n_panels), f(2*(n_panels+1))
    REAL :: cd, l, di, structuremass, drag, aux
    INTRINSIC SUM
    INTRINSIC EXP
    REAL :: arg1
! EXECUTION
    CALL TRANSFER_DISPS(n_panels + 1, xfem, d, xllt)
    CALL TAPENADE_MAIN(n_panels, xllt, gama, alpha0, chords, cl0, cla, &
&                vinf, rhoair, resllt, sref, cl, cd, l, di, loads)
    CALL TRANSFER_FORCES(n_panels + 1, xfem, loads, f)
    CALL FEM_MAIN(n_panels, n_cons, xfem, r, t, f, d, e, rhomat, sigmay&
&           , pks, conids, resfem, structuremass, margins, ksmargin)
    margins = loadfactor*margins + 1 - loadfactor
    ksmargin = ksmargin*loadfactor + 1 - loadfactor
    drag = di + rhoair*SUM(vinf*vinf)/2*sref*cd0
    arg1 = endurance*tsfc*drag/l
    aux = EXP(arg1)
    fb = g*(fixedmass+structuremass)*(aux-1)
    weight = g*(fixedmass+structuremass) + fb
    liftexcess = l/weight - 1
  END SUBROUTINE ASA_ANALYSIS

END MODULE ASA_MODULE_D

