!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.15 (master) - 15 Apr 2020 11:54
!
!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.15 (master) - 15 Apr 2020 11:54
!
MODULE FEM_MODULE_DIFF
  IMPLICIT NONE
  REAL, PARAMETER :: zero=0.0
  REAL, PARAMETER :: pi=3.1415926535897932384626
  REAL, PARAMETER :: eps=EPSILON(zero)

CONTAINS
!  Differentiation of beam_stiffness_matrix in forward (tangent) mode:
!   variations   of useful results: ki ii
!   with respect to varying inputs: ti ki
  SUBROUTINE BEAM_STIFFNESS_MATRIX_D(x1i, x2i, ri, ti, tid, e, ki, kid, &
&   li, ii, iid)
    IMPLICIT NONE
! Input variables
    REAL, INTENT(IN) :: x1i(3), x2i(3), ri, ti, e
    REAL, INTENT(IN) :: tid
! Output variables
    REAL, INTENT(OUT) :: ki(4, 4), li, ii
    REAL, INTENT(OUT) :: kid(4, 4), iid
! Working variables
    REAL :: kk
    REAL :: kkd
    REAL :: temp
! EXECUTION
! Compute the length of the beam
    li = x2i(2) - x1i(2)
! Compute the moment of inertia of a circular beam
    temp = ri*ri*ri
    iid = temp*pi*tid
    ii = temp*(pi*ti)
! Compute the bending term that is common to all elements
! of the stiffness matrix
    temp = li*li*li
    kkd = e*iid/temp
    kk = e*(ii/temp)
! Populate the stiffness matrix
    kid(1, 1) = 12*kkd
    ki(1, 1) = 12*kk
    kid(1, 2) = li*6*kkd
    ki(1, 2) = 6*li*kk
    kid(1, 3) = -(12*kkd)
    ki(1, 3) = -(12*kk)
    kid(1, 4) = li*6*kkd
    ki(1, 4) = 6*li*kk
    kid(2, 1) = li*6*kkd
    ki(2, 1) = 6*li*kk
    kid(2, 2) = li**2*4*kkd
    ki(2, 2) = 4*li**2*kk
    kid(2, 3) = -(li*6*kkd)
    ki(2, 3) = -(6*li*kk)
    kid(2, 4) = li**2*2*kkd
    ki(2, 4) = 2*li**2*kk
    kid(3, 1) = -(12*kkd)
    ki(3, 1) = -(12*kk)
    kid(3, 2) = -(li*6*kkd)
    ki(3, 2) = -(6*li*kk)
    kid(3, 3) = 12*kkd
    ki(3, 3) = 12*kk
    kid(3, 4) = -(li*6*kkd)
    ki(3, 4) = -(6*li*kk)
    kid(4, 1) = li*6*kkd
    ki(4, 1) = 6*li*kk
    kid(4, 2) = li**2*2*kkd
    ki(4, 2) = 2*li**2*kk
    kid(4, 3) = -(li*6*kkd)
    ki(4, 3) = -(6*li*kk)
    kid(4, 4) = li**2*4*kkd
    ki(4, 4) = 4*li**2*kk
  END SUBROUTINE BEAM_STIFFNESS_MATRIX_D

!  Differentiation of beam_stiffness_matrix in reverse (adjoint) mode:
!   gradient     of useful results: ti ki ii
!   with respect to varying inputs: ti ki
  SUBROUTINE BEAM_STIFFNESS_MATRIX_B(x1i, x2i, ri, ti, tib, e, ki, kib, &
&   li, ii, iib)
    IMPLICIT NONE
! Input variables
    REAL, INTENT(IN) :: x1i(3), x2i(3), ri, ti, e
    REAL :: tib
! Output variables
    REAL :: ki(4, 4), li, ii
    REAL :: kib(4, 4), iib
! Working variables
    REAL :: kk
    REAL :: kkb
! EXECUTION
! Compute the length of the beam
    CALL PUSHREAL4(li)
    li = x2i(2) - x1i(2)
! Compute the moment of inertia of a circular beam
    CALL PUSHREAL4(ii)
    ii = pi*ri**3*ti
! Compute the bending term that is common to all elements
! of the stiffness matrix
    kk = e*ii/li**3
! Populate the stiffness matrix
    CALL PUSHREAL4(ki(1, 1))
    ki(1, 1) = 12*kk
    CALL PUSHREAL4(ki(1, 2))
    ki(1, 2) = 6*li*kk
    CALL PUSHREAL4(ki(1, 3))
    ki(1, 3) = -(12*kk)
    CALL PUSHREAL4(ki(1, 4))
    ki(1, 4) = 6*li*kk
    CALL PUSHREAL4(ki(2, 1))
    ki(2, 1) = 6*li*kk
    CALL PUSHREAL4(ki(2, 2))
    ki(2, 2) = 4*li**2*kk
    CALL PUSHREAL4(ki(2, 3))
    ki(2, 3) = -(6*li*kk)
    CALL PUSHREAL4(ki(2, 4))
    ki(2, 4) = 2*li**2*kk
    CALL PUSHREAL4(ki(3, 1))
    ki(3, 1) = -(12*kk)
    CALL PUSHREAL4(ki(3, 2))
    ki(3, 2) = -(6*li*kk)
    CALL PUSHREAL4(ki(3, 3))
    ki(3, 3) = 12*kk
    CALL PUSHREAL4(ki(3, 4))
    ki(3, 4) = -(6*li*kk)
    CALL PUSHREAL4(ki(4, 1))
    ki(4, 1) = 6*li*kk
    CALL PUSHREAL4(ki(4, 2))
    ki(4, 2) = 2*li**2*kk
    CALL PUSHREAL4(ki(4, 3))
    ki(4, 3) = -(6*li*kk)
    CALL PUSHREAL4(ki(4, 4))
    ki(4, 4) = 4*li**2*kk
    CALL POPREAL4(ki(4, 4))
    kkb = 4*li**2*kib(4, 4) + 2*li**2*kib(4, 2) - li*6*kib(4, 3) + li*6*&
&     kib(4, 1) + 12*kib(3, 3) - li*6*kib(3, 4) + 2*li**2*kib(2, 4) - li&
&     *6*kib(3, 2) - 12*kib(3, 1) + 4*li**2*kib(2, 2) - li*6*kib(2, 3) +&
&     li*6*kib(2, 1) + li*6*kib(1, 4) + li*6*kib(1, 2) - 12*kib(1, 3) + &
&     12*kib(1, 1)
    kib(4, 4) = 0.0
    CALL POPREAL4(ki(4, 3))
    kib(4, 3) = 0.0
    CALL POPREAL4(ki(4, 2))
    kib(4, 2) = 0.0
    CALL POPREAL4(ki(4, 1))
    kib(4, 1) = 0.0
    CALL POPREAL4(ki(3, 4))
    kib(3, 4) = 0.0
    CALL POPREAL4(ki(3, 3))
    kib(3, 3) = 0.0
    CALL POPREAL4(ki(3, 2))
    kib(3, 2) = 0.0
    CALL POPREAL4(ki(3, 1))
    kib(3, 1) = 0.0
    CALL POPREAL4(ki(2, 4))
    kib(2, 4) = 0.0
    CALL POPREAL4(ki(2, 3))
    kib(2, 3) = 0.0
    CALL POPREAL4(ki(2, 2))
    kib(2, 2) = 0.0
    CALL POPREAL4(ki(2, 1))
    kib(2, 1) = 0.0
    CALL POPREAL4(ki(1, 4))
    kib(1, 4) = 0.0
    CALL POPREAL4(ki(1, 3))
    kib(1, 3) = 0.0
    CALL POPREAL4(ki(1, 2))
    kib(1, 2) = 0.0
    CALL POPREAL4(ki(1, 1))
    kib(1, 1) = 0.0
    iib = iib + e*kkb/li**3
    CALL POPREAL4(ii)
    tib = tib + pi*ri**3*iib
    CALL POPREAL4(li)
  END SUBROUTINE BEAM_STIFFNESS_MATRIX_B

  SUBROUTINE BEAM_STIFFNESS_MATRIX(x1i, x2i, ri, ti, e, ki, li, ii)
    IMPLICIT NONE
! Input variables
    REAL, INTENT(IN) :: x1i(3), x2i(3), ri, ti, e
! Output variables
    REAL, INTENT(OUT) :: ki(4, 4), li, ii
! Working variables
    REAL :: kk
! EXECUTION
! Compute the length of the beam
    li = x2i(2) - x1i(2)
! Compute the moment of inertia of a circular beam
    ii = pi*ri**3*ti
! Compute the bending term that is common to all elements
! of the stiffness matrix
    kk = e*ii/li**3
! Populate the stiffness matrix
    ki(1, 1) = 12*kk
    ki(1, 2) = 6*li*kk
    ki(1, 3) = -(12*kk)
    ki(1, 4) = 6*li*kk
    ki(2, 1) = 6*li*kk
    ki(2, 2) = 4*li**2*kk
    ki(2, 3) = -(6*li*kk)
    ki(2, 4) = 2*li**2*kk
    ki(3, 1) = -(12*kk)
    ki(3, 2) = -(6*li*kk)
    ki(3, 3) = 12*kk
    ki(3, 4) = -(6*li*kk)
    ki(4, 1) = 6*li*kk
    ki(4, 2) = 2*li**2*kk
    ki(4, 3) = -(6*li*kk)
    ki(4, 4) = 4*li**2*kk
  END SUBROUTINE BEAM_STIFFNESS_MATRIX

!  Differentiation of get_k_matrix in forward (tangent) mode:
!   variations   of useful results: k
!   with respect to varying inputs: t
!============================================================
  SUBROUTINE GET_K_MATRIX_D(n_beams, x, r, t, td, e, k, kd, n_dofs)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_beams
    REAL, INTENT(IN) :: x(3, n_beams+1)
    REAL, INTENT(IN) :: r(n_beams), t(n_beams), e
    REAL, INTENT(IN) :: td(n_beams)
! Output variables
    REAL, INTENT(OUT) :: k(2*(n_beams+1), 2*(n_beams+1))
    REAL, INTENT(OUT) :: kd(2*(n_beams+1), 2*(n_beams+1))
    INTEGER, INTENT(OUT) :: n_dofs
! Working variables
    INTEGER :: jj
    REAL :: x1i(3), x2i(3), ki(4, 4), li, ii
    REAL :: kid(4, 4), iid
! EXECUTION
! Initialize the stifness matrix
    k = zero
    kd = 0.0
    kid = 0.0
! Loop over all beams
    DO jj=1,n_beams
! Get nodal coordinates of the current beam
      x1i = x(:, jj)
      x2i = x(:, jj+1)
! Compute the element stiffness matrix
      CALL BEAM_STIFFNESS_MATRIX_D(x1i, x2i, r(jj), t(jj), td(jj), e, ki&
&                            , kid, li, ii, iid)
! Assign the element matrix to the global matrix
      kd(2*jj-1:2*jj+2, 2*jj-1:2*jj+2) = kd(2*jj-1:2*jj+2, 2*jj-1:2*jj+2&
&       ) + kid
      k(2*jj-1:2*jj+2, 2*jj-1:2*jj+2) = k(2*jj-1:2*jj+2, 2*jj-1:2*jj+2) &
&       + ki
    END DO
! Compute number of degrees of freedom
    n_dofs = 2*(n_beams+1)
  END SUBROUTINE GET_K_MATRIX_D

!  Differentiation of get_k_matrix in reverse (adjoint) mode:
!   gradient     of useful results: k t
!   with respect to varying inputs: t
!============================================================
  SUBROUTINE GET_K_MATRIX_B(n_beams, x, r, t, tb, e, k, kb, n_dofs)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_beams
    REAL, INTENT(IN) :: x(3, n_beams+1)
    REAL, INTENT(IN) :: r(n_beams), t(n_beams), e
    REAL :: tb(n_beams)
! Output variables
    REAL :: k(2*(n_beams+1), 2*(n_beams+1))
    REAL :: kb(2*(n_beams+1), 2*(n_beams+1))
    INTEGER, INTENT(OUT) :: n_dofs
! Working variables
    INTEGER :: jj
    REAL :: x1i(3), x2i(3), ki(4, 4), li, ii
    REAL :: kib(4, 4), iib
! EXECUTION
! Initialize the stifness matrix
    k = zero
! Loop over all beams
    DO jj=1,n_beams
! Get nodal coordinates of the current beam
      CALL PUSHREAL4ARRAY(x1i, 3)
      x1i = x(:, jj)
      CALL PUSHREAL4ARRAY(x2i, 3)
      x2i = x(:, jj+1)
! Compute the element stiffness matrix
      CALL BEAM_STIFFNESS_MATRIX(x1i, x2i, r(jj), t(jj), e, ki, li, ii)
! Assign the element matrix to the global matrix
      k(2*jj-1:2*jj+2, 2*jj-1:2*jj+2) = k(2*jj-1:2*jj+2, 2*jj-1:2*jj+2) &
&       + ki
    END DO
! Compute number of degrees of freedom
    n_dofs = 2*(n_beams+1)
    kib = 0.0
    DO jj=n_beams,1,-1
      kib = kib + kb(2*jj-1:2*jj+2, 2*jj-1:2*jj+2)
      iib = 0.0
      CALL BEAM_STIFFNESS_MATRIX_B(x1i, x2i, r(jj), t(jj), tb(jj), e, ki&
&                            , kib, li, ii, iib)
      CALL POPREAL4ARRAY(x2i, 3)
      CALL POPREAL4ARRAY(x1i, 3)
    END DO
  END SUBROUTINE GET_K_MATRIX_B

!============================================================
  SUBROUTINE GET_K_MATRIX(n_beams, x, r, t, e, k, n_dofs)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_beams
    REAL, INTENT(IN) :: x(3, n_beams+1)
    REAL, INTENT(IN) :: r(n_beams), t(n_beams), e
! Output variables
    REAL, INTENT(OUT) :: k(2*(n_beams+1), 2*(n_beams+1))
    INTEGER, INTENT(OUT) :: n_dofs
! Working variables
    INTEGER :: jj
    REAL :: x1i(3), x2i(3), ki(4, 4), li, ii
! EXECUTION
! Initialize the stifness matrix
    k = zero
! Loop over all beams
    DO jj=1,n_beams
! Get nodal coordinates of the current beam
      x1i = x(:, jj)
      x2i = x(:, jj+1)
! Compute the element stiffness matrix
      CALL BEAM_STIFFNESS_MATRIX(x1i, x2i, r(jj), t(jj), e, ki, li, ii)
! Assign the element matrix to the global matrix
      k(2*jj-1:2*jj+2, 2*jj-1:2*jj+2) = k(2*jj-1:2*jj+2, 2*jj-1:2*jj+2) &
&       + ki
    END DO
! Compute number of degrees of freedom
    n_dofs = 2*(n_beams+1)
  END SUBROUTINE GET_K_MATRIX

!  Differentiation of apply_cons in forward (tangent) mode:
!   variations   of useful results: f k
!   with respect to varying inputs: f k
!============================================================
  SUBROUTINE APPLY_CONS_D(n_dofs, n_cons, conids, k, kd, f, fd)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_dofs, n_cons
    INTEGER, INTENT(IN) :: conids(n_cons)
! Output variables
    REAL, INTENT(INOUT) :: k(n_dofs, n_dofs)
    REAL, INTENT(INOUT) :: kd(n_dofs, n_dofs)
    REAL, INTENT(INOUT) :: f(n_dofs)
    REAL, INTENT(INOUT) :: fd(n_dofs)
! Working variables
    INTEGER :: ii, curr_con
! EXECUTION
! First we will create the array freeIDs containing all indices
! of the free DOFs. Then we will use this array to crop Kf and ff.
! Now we set the indices of the constrained DOFs to zero
    DO ii=1,n_cons
      curr_con = conids(ii)
! We will modify K and f so that d(curr_con) is forced to be zero.
! We can do that by setting:
! f(curr_con)=0, K(curr_con,:)=0, K(:,curr_con)=1,
! and K(curr_con,curr_con)=1.
! Modify the K matrix
      kd(curr_con, :) = 0.0
      k(curr_con, :) = 0.0
      kd(:, curr_con) = 0.0
      k(:, curr_con) = 0.0
      kd(curr_con, curr_con) = 0.0
      k(curr_con, curr_con) = 1.0
! Modify the f vector
      fd(curr_con) = 0.0
      f(curr_con) = 0.0
    END DO
  END SUBROUTINE APPLY_CONS_D

!  Differentiation of apply_cons in reverse (adjoint) mode:
!   gradient     of useful results: f k
!   with respect to varying inputs: f k
!============================================================
  SUBROUTINE APPLY_CONS_B(n_dofs, n_cons, conids, k, kb, f, fb)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_dofs, n_cons
    INTEGER, INTENT(IN) :: conids(n_cons)
! Output variables
    REAL, INTENT(INOUT) :: k(n_dofs, n_dofs)
    REAL, INTENT(INOUT) :: kb(n_dofs, n_dofs)
    REAL, INTENT(INOUT) :: f(n_dofs)
    REAL, INTENT(INOUT) :: fb(n_dofs)
! Working variables
    INTEGER :: ii, curr_con
! EXECUTION
! First we will create the array freeIDs containing all indices
! of the free DOFs. Then we will use this array to crop Kf and ff.
! Now we set the indices of the constrained DOFs to zero
    DO ii=1,n_cons
      CALL PUSHINTEGER4(curr_con)
      curr_con = conids(ii)
! We will modify K and f so that d(curr_con) is forced to be zero.
! We can do that by setting:
! f(curr_con)=0, K(curr_con,:)=0, K(:,curr_con)=1,
! and K(curr_con,curr_con)=1.
! Modify the K matrix
      k(curr_con, :) = 0.0
      k(:, curr_con) = 0.0
      k(curr_con, curr_con) = 1.0
! Modify the f vector
      f(curr_con) = 0.0
    END DO
    DO ii=n_cons,1,-1
      fb(curr_con) = 0.0
      kb(curr_con, curr_con) = 0.0
      kb(:, curr_con) = 0.0
      kb(curr_con, :) = 0.0
      CALL POPINTEGER4(curr_con)
    END DO
  END SUBROUTINE APPLY_CONS_B

!============================================================
  SUBROUTINE APPLY_CONS(n_dofs, n_cons, conids, k, f)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_dofs, n_cons
    INTEGER, INTENT(IN) :: conids(n_cons)
! Output variables
    REAL, INTENT(INOUT) :: k(n_dofs, n_dofs)
    REAL, INTENT(INOUT) :: f(n_dofs)
! Working variables
    INTEGER :: ii, curr_con
! EXECUTION
! First we will create the array freeIDs containing all indices
! of the free DOFs. Then we will use this array to crop Kf and ff.
! Now we set the indices of the constrained DOFs to zero
    DO ii=1,n_cons
      curr_con = conids(ii)
! We will modify K and f so that d(curr_con) is forced to be zero.
! We can do that by setting:
! f(curr_con)=0, K(curr_con,:)=0, K(:,curr_con)=1,
! and K(curr_con,curr_con)=1.
! Modify the K matrix
      k(curr_con, :) = 0.0
      k(:, curr_con) = 0.0
      k(curr_con, curr_con) = 1.0
! Modify the f vector
      f(curr_con) = 0.0
    END DO
  END SUBROUTINE APPLY_CONS

!  Differentiation of get_residuals in forward (tangent) mode:
!   variations   of useful results: res
!   with respect to varying inputs: d f t
!============================================================
  SUBROUTINE GET_RESIDUALS_D0(n_beams, n_cons, x, r, t, td, f, fd, d, dd&
&   , e, conids, res, resd)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_beams, n_cons
    REAL, INTENT(IN) :: x(3, n_beams+1)
    REAL, INTENT(IN) :: r(n_beams), t(n_beams)
    REAL, INTENT(IN) :: td(n_beams)
    REAL, INTENT(IN) :: f(2*(n_beams+1)), d(2*(n_beams+1)), e
    REAL, INTENT(IN) :: fd(2*(n_beams+1)), dd(2*(n_beams+1))
    INTEGER, INTENT(IN) :: conids(n_cons)
! Output variables
    REAL, INTENT(OUT) :: res(2*(n_beams+1))
    REAL, INTENT(OUT) :: resd(2*(n_beams+1))
! Working variables
    REAL :: k(2*(n_beams+1), 2*(n_beams+1)), fcopy(2*(n_beams+1))
    REAL :: kd0(2*(n_beams+1), 2*(n_beams+1)), fcopyd(2*(n_beams+1))
    REAL :: kd(2*(n_beams+1))
    REAL :: kdd(2*(n_beams+1))
    INTEGER :: n_dofs
! EXECUTION
! Build the full stiffness matrix
    CALL GET_K_MATRIX_D(n_beams, x, r, t, td, e, k, kd0, n_dofs)
! Make a copy of the force vector so we can modify its elements
    fcopyd = fd
    fcopy = f
! Apply the constraints
    CALL APPLY_CONS_D(n_dofs, n_cons, conids, k, kd0, fcopy, fcopyd)
! Compute K*d
    CALL MATDOTVEC_D(n_dofs, k, kd0, d, dd, kd, kdd)
! Compute the residuals
    resd = kdd - fcopyd
    res = kd - fcopy
  END SUBROUTINE GET_RESIDUALS_D0

!  Differentiation of get_residuals in reverse (adjoint) mode:
!   gradient     of useful results: res d t
!   with respect to varying inputs: d f t
!============================================================
  SUBROUTINE GET_RESIDUALS_B0(n_beams, n_cons, x, r, t, tb, f, fb, d, db&
&   , e, conids, res, resb)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_beams, n_cons
    REAL, INTENT(IN) :: x(3, n_beams+1)
    REAL, INTENT(IN) :: r(n_beams), t(n_beams)
    REAL :: tb(n_beams)
    REAL, INTENT(IN) :: f(2*(n_beams+1)), d(2*(n_beams+1)), e
    REAL :: fb(2*(n_beams+1)), db(2*(n_beams+1))
    INTEGER, INTENT(IN) :: conids(n_cons)
! Output variables
    REAL :: res(2*(n_beams+1))
    REAL :: resb(2*(n_beams+1))
! Working variables
    REAL :: k(2*(n_beams+1), 2*(n_beams+1)), fcopy(2*(n_beams+1))
    REAL :: kb(2*(n_beams+1), 2*(n_beams+1)), fcopyb(2*(n_beams+1))
    REAL :: kd(2*(n_beams+1))
    REAL :: kdb(2*(n_beams+1))
    INTEGER :: n_dofs
! EXECUTION
! Build the full stiffness matrix
    CALL GET_K_MATRIX(n_beams, x, r, t, e, k, n_dofs)
! Make a copy of the force vector so we can modify its elements
    fcopy = f
! Apply the constraints
    CALL APPLY_CONS(n_dofs, n_cons, conids, k, fcopy)
! Compute K*d
    CALL MATDOTVEC(n_dofs, k, d, kd)
! Compute the residuals
    res = kd - fcopy
    fcopyb = 0.0
    kdb = 0.0
    kdb = resb
    fcopyb = -resb
    kb = 0.0
    CALL MATDOTVEC_B(n_dofs, k, kb, d, db, kd, kdb)
    CALL APPLY_CONS_B(n_dofs, n_cons, conids, k, kb, fcopy, fcopyb)
    fb = 0.0
    fb = fcopyb
    CALL GET_K_MATRIX_B(n_beams, x, r, t, tb, e, k, kb, n_dofs)
  END SUBROUTINE GET_RESIDUALS_B0

!============================================================
  SUBROUTINE GET_RESIDUALS(n_beams, n_cons, x, r, t, f, d, e, conids, &
&   res)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_beams, n_cons
    REAL, INTENT(IN) :: x(3, n_beams+1)
    REAL, INTENT(IN) :: r(n_beams), t(n_beams)
    REAL, INTENT(IN) :: f(2*(n_beams+1)), d(2*(n_beams+1)), e
    INTEGER, INTENT(IN) :: conids(n_cons)
! Output variables
    REAL, INTENT(OUT) :: res(2*(n_beams+1))
! Working variables
    REAL :: k(2*(n_beams+1), 2*(n_beams+1)), fcopy(2*(n_beams+1))
    REAL :: kd(2*(n_beams+1))
    INTEGER :: n_dofs
! EXECUTION
! Build the full stiffness matrix
    CALL GET_K_MATRIX(n_beams, x, r, t, e, k, n_dofs)
! Make a copy of the force vector so we can modify its elements
    fcopy = f
! Apply the constraints
    CALL APPLY_CONS(n_dofs, n_cons, conids, k, fcopy)
! Compute K*d
    CALL MATDOTVEC(n_dofs, k, d, kd)
! Compute the residuals
    res = kd - fcopy
  END SUBROUTINE GET_RESIDUALS

!  Differentiation of get_functions in forward (tangent) mode:
!   variations   of useful results: mass ksmargin margins
!   with respect to varying inputs: d t margins
!============================================================
  SUBROUTINE GET_FUNCTIONS_D0(n_beams, n_cons, x, r, t, td, f, d, dd, e&
&   , rho, sigmay, pks, conids, mass, massd, margins, marginsd, ksmargin&
&   , ksmargind)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_beams, n_cons
    REAL, INTENT(IN) :: x(3, n_beams+1)
    REAL, INTENT(IN) :: r(n_beams), t(n_beams)
    REAL, INTENT(IN) :: td(n_beams)
    REAL, INTENT(IN) :: f(2*(n_beams+1)), d(2*(n_beams+1))
    REAL, INTENT(IN) :: dd(2*(n_beams+1))
    REAL, INTENT(IN) :: e, rho, sigmay, pks
    INTEGER, INTENT(IN) :: conids(n_cons)
! Output variables
    REAL, INTENT(OUT) :: mass, margins(2*n_beams), ksmargin
    REAL, INTENT(OUT) :: massd, marginsd(2*n_beams), ksmargind
! Working variables
    REAL :: k(2*(n_beams+1), 2*(n_beams+1)), fcopy(2*(n_beams+1))
    REAL :: kd(2*(n_beams+1))
    REAL :: x1i(3), x2i(3), ki(4, 4), li, ii, di(4), fi(4), ai
    REAL :: kid(4, 4), iid, did(4), fid(4), aid
    REAL :: sigma1, sigma2, tau, sigma_vm1, sigma_vm2
    REAL :: sigma1d, sigma2d, taud, sigma_vm1d, sigma_vm2d
    REAL :: margin_min, margin_sum
    REAL :: margin_sumd
    INTEGER :: n_dofs, jj
    INTRINSIC SQRT
    INTRINSIC EXP
    INTRINSIC SUM
    INTRINSIC LOG
    REAL :: temp
    REAL :: temp0
! EXECUTION
! Initialize the mass value
    mass = 0
    massd = 0.0
    kid = 0.0
! Loop over every element to compute contributions of mass and stress
    DO jj=1,n_beams
! Get nodal coordinates of the current beam
      x1i = x(:, jj)
      x2i = x(:, jj+1)
! Get element properties
      CALL BEAM_STIFFNESS_MATRIX_D(x1i, x2i, r(jj), t(jj), td(jj), e, ki&
&                            , kid, li, ii, iid)
! Compute section area
      aid = pi*2.0*r(jj)*td(jj)
      ai = 2.0*pi*r(jj)*t(jj)
! Compute mass contribution
      massd = massd + rho*li*aid
      mass = mass + rho*ai*li
! Get DOF values of the current nodes
      did = dd(2*jj-1:2*jj+2)
      di = d(2*jj-1:2*jj+2)
! Compute corresponding local nodal forces
      CALL MATDOTVEC_D(4, ki, kid, di, did, fi, fid)
! Compute bending stress on node 1 (sigma = M*y/I)
      temp = fi(2)/ii
      sigma1d = r(jj)*(fid(2)-temp*iid)/ii
      sigma1 = r(jj)*temp
! Compute bending stress on node 2 (sigma = M*y/I)
      temp = fi(4)/ii
      sigma2d = r(jj)*(fid(4)-temp*iid)/ii
      sigma2 = r(jj)*temp
! Compute shear stress on the beam (it is constant)
! We need 2.0 because shear is maximum at the midplane
      temp = fi(1)/ai
      taud = 2.0*(fid(1)-temp*aid)/ai
      tau = 2.0*temp
! Compute the Von Mises stress for each node
! This is a conservative measure, since we are using the
! maximum bending stress and the maximum shear stress, even though
! they are at different locations of the cross-section.
      temp = sigma1*sigma1 + 3.0*(tau*tau)
      temp0 = SQRT(temp)
      IF (temp .EQ. 0.0) THEN
        sigma_vm1d = 0.0
      ELSE
        sigma_vm1d = (2*sigma1*sigma1d+3.0*2*tau*taud)/(2.0*temp0)
      END IF
      sigma_vm1 = temp0
      temp0 = sigma2*sigma2 + 3.0*(tau*tau)
      temp = SQRT(temp0)
      IF (temp0 .EQ. 0.0) THEN
        sigma_vm2d = 0.0
      ELSE
        sigma_vm2d = (2*sigma2*sigma2d+3.0*2*tau*taud)/(2.0*temp)
      END IF
      sigma_vm2 = temp
! Compute the safety margin with respect to the failure
      marginsd(2*jj-1) = -(sigma_vm1d/sigmay)
      margins(2*jj-1) = 1.0 - sigma_vm1/sigmay
      marginsd(2*jj) = -(sigma_vm2d/sigmay)
      margins(2*jj) = 1.0 - sigma_vm2/sigmay
    END DO
! The KS function estimates the maximum value from the set.
! But the minimum margin is the most critical one.
! So we flip the sign of the margins to
! compute the KS value.
! Find the minimum safety margin (most critical case)
! NOTE: I deactivated this since the changes in the minimum values
! caused discrepancies with respect to the finite difference test
! when checking derivatives.
!1.0
    margin_min = 0.0
!do jj=1,2*n_beams
!   margin_min = min(margin_min, margins(jj))
!end do
! Compute sum of the KS expression inside the natural logarithm.
! Note that we flipped the margins signs.
    margin_sumd = SUM(-(EXP(pks*(margin_min-margins))*pks*marginsd))
    margin_sum = SUM(EXP(pks*(-margins+margin_min)))
! Aggregate stresses
    ksmargind = -(margin_sumd/(pks*margin_sum))
    ksmargin = margin_min - 1.0/pks*LOG(margin_sum)
  END SUBROUTINE GET_FUNCTIONS_D0

!  Differentiation of get_functions in reverse (adjoint) mode:
!   gradient     of useful results: mass ksmargin margins
!   with respect to varying inputs: d t margins
!============================================================
  SUBROUTINE GET_FUNCTIONS_B0(n_beams, n_cons, x, r, t, tb, f, d, db, e&
&   , rho, sigmay, pks, conids, mass, massb, margins, marginsb, ksmargin&
&   , ksmarginb)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_beams, n_cons
    REAL, INTENT(IN) :: x(3, n_beams+1)
    REAL, INTENT(IN) :: r(n_beams), t(n_beams)
    REAL :: tb(n_beams)
    REAL, INTENT(IN) :: f(2*(n_beams+1)), d(2*(n_beams+1))
    REAL :: db(2*(n_beams+1))
    REAL, INTENT(IN) :: e, rho, sigmay, pks
    INTEGER, INTENT(IN) :: conids(n_cons)
! Output variables
    REAL :: mass, margins(2*n_beams), ksmargin
    REAL :: massb, marginsb(2*n_beams), ksmarginb
! Working variables
    REAL :: k(2*(n_beams+1), 2*(n_beams+1)), fcopy(2*(n_beams+1))
    REAL :: kd(2*(n_beams+1))
    REAL :: x1i(3), x2i(3), ki(4, 4), li, ii, di(4), fi(4), ai
    REAL :: kib(4, 4), iib, dib(4), fib(4), aib
    REAL :: sigma1, sigma2, tau, sigma_vm1, sigma_vm2
    REAL :: sigma1b, sigma2b, taub, sigma_vm1b, sigma_vm2b
    REAL :: margin_min, margin_sum
    REAL :: margin_sumb
    INTEGER :: n_dofs, jj
    INTRINSIC SQRT
    INTRINSIC EXP
    INTRINSIC SUM
    INTRINSIC LOG
    REAL :: tempb
! EXECUTION
! Initialize the mass value
    mass = 0
! Loop over every element to compute contributions of mass and stress
    DO jj=1,n_beams
! Get nodal coordinates of the current beam
      CALL PUSHREAL4ARRAY(x1i, 3)
      x1i = x(:, jj)
      CALL PUSHREAL4ARRAY(x2i, 3)
      x2i = x(:, jj+1)
! Get element properties
      CALL PUSHREAL4(ii)
      CALL PUSHREAL4(li)
      CALL PUSHREAL4ARRAY(ki, 4**2)
      CALL BEAM_STIFFNESS_MATRIX(x1i, x2i, r(jj), t(jj), e, ki, li, ii)
! Compute section area
      CALL PUSHREAL4(ai)
      ai = 2.0*pi*r(jj)*t(jj)
! Compute mass contribution
      mass = mass + rho*ai*li
! Get DOF values of the current nodes
      CALL PUSHREAL4ARRAY(di, 4)
      di = d(2*jj-1:2*jj+2)
! Compute corresponding local nodal forces
      CALL PUSHREAL4ARRAY(fi, 4)
      CALL MATDOTVEC(4, ki, di, fi)
! Compute bending stress on node 1 (sigma = M*y/I)
      CALL PUSHREAL4(sigma1)
      sigma1 = fi(2)*r(jj)/ii
! Compute bending stress on node 2 (sigma = M*y/I)
      CALL PUSHREAL4(sigma2)
      sigma2 = fi(4)*r(jj)/ii
! Compute shear stress on the beam (it is constant)
! We need 2.0 because shear is maximum at the midplane
      CALL PUSHREAL4(tau)
      tau = 2.0*fi(1)/ai
! Compute the Von Mises stress for each node
! This is a conservative measure, since we are using the
! maximum bending stress and the maximum shear stress, even though
! they are at different locations of the cross-section.
      sigma_vm1 = SQRT(sigma1**2 + 3.0*tau**2)
      sigma_vm2 = SQRT(sigma2**2 + 3.0*tau**2)
! Compute the safety margin with respect to the failure
      margins(2*jj-1) = 1.0 - sigma_vm1/sigmay
      margins(2*jj) = 1.0 - sigma_vm2/sigmay
    END DO
! The KS function estimates the maximum value from the set.
! But the minimum margin is the most critical one.
! So we flip the sign of the margins to
! compute the KS value.
! Find the minimum safety margin (most critical case)
! NOTE: I deactivated this since the changes in the minimum values
! caused discrepancies with respect to the finite difference test
! when checking derivatives.
!1.0
    margin_min = 0.0
!do jj=1,2*n_beams
!   margin_min = min(margin_min, margins(jj))
!end do
! Compute sum of the KS expression inside the natural logarithm.
! Note that we flipped the margins signs.
    margin_sum = SUM(EXP(pks*(-margins+margin_min)))
! Aggregate stresses
    ksmargin = margin_min - 1.0/pks*LOG(margin_sum)
    margin_sumb = -(ksmarginb/(margin_sum*pks))
    marginsb = marginsb - pks*EXP(pks*(margin_min-margins))*margin_sumb
    db = 0.0
    tb = 0.0
    kib = 0.0
    DO jj=n_beams,1,-1
      sigma_vm2b = -(marginsb(2*jj)/sigmay)
      marginsb(2*jj) = 0.0
      sigma_vm1b = -(marginsb(2*jj-1)/sigmay)
      marginsb(2*jj-1) = 0.0
      IF (sigma2**2 + 3.0*tau**2 .EQ. 0.0) THEN
        tempb = 0.0
      ELSE
        tempb = sigma_vm2b/(2.0*SQRT(sigma2**2+3.0*tau**2))
      END IF
      sigma2b = 2*sigma2*tempb
      taub = 2*tau*3.0*tempb
      IF (sigma1**2 + 3.0*tau**2 .EQ. 0.0) THEN
        tempb = 0.0
      ELSE
        tempb = sigma_vm1b/(2.0*SQRT(sigma1**2+3.0*tau**2))
      END IF
      sigma1b = 2*sigma1*tempb
      taub = taub + 2*tau*3.0*tempb
      fib = 0.0
      CALL POPREAL4(tau)
      tempb = 2.0*taub/ai
      fib(1) = fib(1) + tempb
      aib = rho*li*massb - fi(1)*tempb/ai
      CALL POPREAL4(sigma2)
      tempb = r(jj)*sigma2b/ii
      fib(4) = fib(4) + tempb
      iib = -(fi(4)*tempb/ii)
      CALL POPREAL4(sigma1)
      tempb = r(jj)*sigma1b/ii
      fib(2) = fib(2) + tempb
      iib = iib - fi(2)*tempb/ii
      CALL POPREAL4ARRAY(fi, 4)
      dib = 0.0
      CALL MATDOTVEC_B(4, ki, kib, di, dib, fi, fib)
      CALL POPREAL4ARRAY(di, 4)
      db(2*jj-1:2*jj+2) = db(2*jj-1:2*jj+2) + dib
      CALL POPREAL4(ai)
      tb(jj) = tb(jj) + r(jj)*pi*2.0*aib
      CALL POPREAL4ARRAY(ki, 4**2)
      CALL POPREAL4(li)
      CALL POPREAL4(ii)
      CALL BEAM_STIFFNESS_MATRIX_B(x1i, x2i, r(jj), t(jj), tb(jj), e, ki&
&                            , kib, li, ii, iib)
      CALL POPREAL4ARRAY(x2i, 3)
      CALL POPREAL4ARRAY(x1i, 3)
    END DO
  END SUBROUTINE GET_FUNCTIONS_B0

!============================================================
  SUBROUTINE GET_FUNCTIONS(n_beams, n_cons, x, r, t, f, d, e, rho, &
&   sigmay, pks, conids, mass, margins, ksmargin)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_beams, n_cons
    REAL, INTENT(IN) :: x(3, n_beams+1)
    REAL, INTENT(IN) :: r(n_beams), t(n_beams)
    REAL, INTENT(IN) :: f(2*(n_beams+1)), d(2*(n_beams+1))
    REAL, INTENT(IN) :: e, rho, sigmay, pks
    INTEGER, INTENT(IN) :: conids(n_cons)
! Output variables
    REAL, INTENT(OUT) :: mass, margins(2*n_beams), ksmargin
! Working variables
    REAL :: k(2*(n_beams+1), 2*(n_beams+1)), fcopy(2*(n_beams+1))
    REAL :: kd(2*(n_beams+1))
    REAL :: x1i(3), x2i(3), ki(4, 4), li, ii, di(4), fi(4), ai
    REAL :: sigma1, sigma2, tau, sigma_vm1, sigma_vm2
    REAL :: margin_min, margin_sum
    INTEGER :: n_dofs, jj
    INTRINSIC SQRT
    INTRINSIC EXP
    INTRINSIC SUM
    INTRINSIC LOG
! EXECUTION
! Initialize the mass value
    mass = 0
! Loop over every element to compute contributions of mass and stress
    DO jj=1,n_beams
! Get nodal coordinates of the current beam
      x1i = x(:, jj)
      x2i = x(:, jj+1)
! Get element properties
      CALL BEAM_STIFFNESS_MATRIX(x1i, x2i, r(jj), t(jj), e, ki, li, ii)
! Compute section area
      ai = 2.0*pi*r(jj)*t(jj)
! Compute mass contribution
      mass = mass + rho*ai*li
! Get DOF values of the current nodes
      di = d(2*jj-1:2*jj+2)
! Compute corresponding local nodal forces
      CALL MATDOTVEC(4, ki, di, fi)
! Compute bending stress on node 1 (sigma = M*y/I)
      sigma1 = fi(2)*r(jj)/ii
! Compute bending stress on node 2 (sigma = M*y/I)
      sigma2 = fi(4)*r(jj)/ii
! Compute shear stress on the beam (it is constant)
! We need 2.0 because shear is maximum at the midplane
      tau = 2.0*fi(1)/ai
! Compute the Von Mises stress for each node
! This is a conservative measure, since we are using the
! maximum bending stress and the maximum shear stress, even though
! they are at different locations of the cross-section.
      sigma_vm1 = SQRT(sigma1**2 + 3.0*tau**2)
      sigma_vm2 = SQRT(sigma2**2 + 3.0*tau**2)
! Compute the safety margin with respect to the failure
      margins(2*jj-1) = 1.0 - sigma_vm1/sigmay
      margins(2*jj) = 1.0 - sigma_vm2/sigmay
    END DO
! The KS function estimates the maximum value from the set.
! But the minimum margin is the most critical one.
! So we flip the sign of the margins to
! compute the KS value.
! Find the minimum safety margin (most critical case)
! NOTE: I deactivated this since the changes in the minimum values
! caused discrepancies with respect to the finite difference test
! when checking derivatives.
!1.0
    margin_min = 0.0
!do jj=1,2*n_beams
!   margin_min = min(margin_min, margins(jj))
!end do
! Compute sum of the KS expression inside the natural logarithm.
! Note that we flipped the margins signs.
    margin_sum = SUM(EXP(pks*(-margins+margin_min)))
! Aggregate stresses
    ksmargin = margin_min - 1.0/pks*LOG(margin_sum)
  END SUBROUTINE GET_FUNCTIONS

!  Differentiation of matdotvec in forward (tangent) mode:
!   variations   of useful results: kd
!   with respect to varying inputs: d k
!============================================================
  SUBROUTINE MATDOTVEC_D(n, k, kd0, d, dd, kd, kdd)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n
    REAL, INTENT(IN) :: k(n, n), d(n)
    REAL, INTENT(IN) :: kd0(n, n), dd(n)
! Output variables
    REAL, INTENT(OUT) :: kd(n)
    REAL, INTENT(OUT) :: kdd(n)
! Working variables
    INTEGER :: ii
! EXECUTION
    kd = 0.0
    kdd = 0.0
    DO ii=1,n
      kdd = kdd + d(ii)*kd0(:, ii) + k(:, ii)*dd(ii)
      kd = kd + k(:, ii)*d(ii)
    END DO
  END SUBROUTINE MATDOTVEC_D

!  Differentiation of matdotvec in reverse (adjoint) mode:
!   gradient     of useful results: d k kd
!   with respect to varying inputs: d k
!============================================================
  SUBROUTINE MATDOTVEC_B(n, k, kb, d, db, kd, kdb)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n
    REAL, INTENT(IN) :: k(n, n), d(n)
    REAL :: kb(n, n), db(n)
! Output variables
    REAL :: kd(n)
    REAL :: kdb(n)
! Working variables
    INTEGER :: ii
! EXECUTION
    CALL PUSHREAL4ARRAY(kd, n)
    kd = 0.0
    DO ii=1,n
      kd = kd + k(:, ii)*d(ii)
    END DO
    DO ii=n,1,-1
      kb(:, ii) = kb(:, ii) + d(ii)*kdb
      db(ii) = db(ii) + SUM(k(:, ii)*kdb)
    END DO
    CALL POPREAL4ARRAY(kd, n)
  END SUBROUTINE MATDOTVEC_B

!============================================================
  SUBROUTINE MATDOTVEC(n, k, d, kd)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n
    REAL, INTENT(IN) :: k(n, n), d(n)
! Output variables
    REAL, INTENT(OUT) :: kd(n)
! Working variables
    INTEGER :: ii
! EXECUTION
    kd = 0.0
    DO ii=1,n
      kd = kd + k(:, ii)*d(ii)
    END DO
  END SUBROUTINE MATDOTVEC

!  Differentiation of fem_main in forward (tangent) mode:
!   variations   of useful results: res mass ksmargin margins
!   with respect to varying inputs: d f t margins
!============================================================
  SUBROUTINE FEM_MAIN_D(n_beams, n_cons, x, r, t, td, f, fd, d, dd, e, &
&   rho, sigmay, pks, conids, res, resd, mass, massd, margins, marginsd&
&   , ksmargin, ksmargind)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_beams, n_cons
    REAL, INTENT(IN) :: x(3, n_beams+1)
    REAL, INTENT(IN) :: r(n_beams), t(n_beams)
    REAL, INTENT(IN) :: td(n_beams)
    REAL, INTENT(IN) :: f(2*(n_beams+1)), d(2*(n_beams+1))
    REAL, INTENT(IN) :: fd(2*(n_beams+1)), dd(2*(n_beams+1))
    REAL, INTENT(IN) :: e, rho, sigmay, pks
    INTEGER, INTENT(IN) :: conids(n_cons)
! Output variables
    REAL, INTENT(OUT) :: res(2*(n_beams+1)), mass, margins(2*n_beams), &
&   ksmargin
    REAL, INTENT(OUT) :: resd(2*(n_beams+1)), massd, marginsd(2*n_beams)&
&   , ksmargind
! EXECUTION
! Call relevant subroutines
    CALL GET_RESIDUALS_D0(n_beams, n_cons, x, r, t, td, f, fd, d, dd, e&
&                   , conids, res, resd)
    CALL GET_FUNCTIONS_D0(n_beams, n_cons, x, r, t, td, f, d, dd, e, rho&
&                   , sigmay, pks, conids, mass, massd, margins, &
&                   marginsd, ksmargin, ksmargind)
  END SUBROUTINE FEM_MAIN_D

!  Differentiation of fem_main in reverse (adjoint) mode:
!   gradient     of useful results: res mass ksmargin margins
!   with respect to varying inputs: d f t margins
!============================================================
  SUBROUTINE FEM_MAIN_B(n_beams, n_cons, x, r, t, tb, f, fb, d, db, e, &
&   rho, sigmay, pks, conids, res, resb, mass, massb, margins, marginsb&
&   , ksmargin, ksmarginb)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_beams, n_cons
    REAL, INTENT(IN) :: x(3, n_beams+1)
    REAL, INTENT(IN) :: r(n_beams), t(n_beams)
    REAL :: tb(n_beams)
    REAL, INTENT(IN) :: f(2*(n_beams+1)), d(2*(n_beams+1))
    REAL :: fb(2*(n_beams+1)), db(2*(n_beams+1))
    REAL, INTENT(IN) :: e, rho, sigmay, pks
    INTEGER, INTENT(IN) :: conids(n_cons)
! Output variables
    REAL :: res(2*(n_beams+1)), mass, margins(2*n_beams), ksmargin
    REAL :: resb(2*(n_beams+1)), massb, marginsb(2*n_beams), ksmarginb
! EXECUTION
! Call relevant subroutines
    CALL GET_RESIDUALS(n_beams, n_cons, x, r, t, f, d, e, conids, res)
    CALL PUSHREAL4ARRAY(margins, 2*n_beams)
    CALL GET_FUNCTIONS(n_beams, n_cons, x, r, t, f, d, e, rho, sigmay, &
&                pks, conids, mass, margins, ksmargin)
    CALL POPREAL4ARRAY(margins, 2*n_beams)
    CALL GET_FUNCTIONS_B0(n_beams, n_cons, x, r, t, tb, f, d, db, e, rho&
&                   , sigmay, pks, conids, mass, massb, margins, &
&                   marginsb, ksmargin, ksmarginb)
    CALL GET_RESIDUALS_B0(n_beams, n_cons, x, r, t, tb, f, fb, d, db, e&
&                   , conids, res, resb)
  END SUBROUTINE FEM_MAIN_B

!============================================================
  SUBROUTINE FEM_MAIN(n_beams, n_cons, x, r, t, f, d, e, rho, sigmay, &
&   pks, conids, res, mass, margins, ksmargin)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_beams, n_cons
    REAL, INTENT(IN) :: x(3, n_beams+1)
    REAL, INTENT(IN) :: r(n_beams), t(n_beams)
    REAL, INTENT(IN) :: f(2*(n_beams+1)), d(2*(n_beams+1))
    REAL, INTENT(IN) :: e, rho, sigmay, pks
    INTEGER, INTENT(IN) :: conids(n_cons)
! Output variables
    REAL, INTENT(OUT) :: res(2*(n_beams+1)), mass, margins(2*n_beams), &
&   ksmargin
! EXECUTION
! Call relevant subroutines
    CALL GET_RESIDUALS(n_beams, n_cons, x, r, t, f, d, e, conids, res)
    CALL GET_FUNCTIONS(n_beams, n_cons, x, r, t, f, d, e, rho, sigmay, &
&                pks, conids, mass, margins, ksmargin)
  END SUBROUTINE FEM_MAIN

END MODULE FEM_MODULE_DIFF


!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.15 (master) - 15 Apr 2020 11:54
!
MODULE LLT_MODULE_DIFF
  IMPLICIT NONE
  REAL, PARAMETER :: zero=0.0
  REAL, PARAMETER :: pi=3.1415926535897932384626
  REAL, PARAMETER :: eps=EPSILON(zero)

CONTAINS
!  Differentiation of induced_vel in forward (tangent) mode:
!   variations   of useful results: gamma_ind
!   with respect to varying inputs: xp x1 x2
  SUBROUTINE INDUCED_VEL_D(uinf, x1, x1d, x2, x2d, xp, xpd, gamma_ind, &
&   gamma_indd)
    IMPLICIT NONE
! Input variables
    REAL, INTENT(IN) :: uinf(3), x1(3), x2(3), xp(3)
    REAL, INTENT(IN) :: x1d(3), x2d(3), xpd(3)
! Output variables
    REAL, INTENT(OUT) :: gamma_ind(3)
    REAL, INTENT(OUT) :: gamma_indd(3)
! Working variables
    REAL :: r1(3), r2(3), v1(3), v2(3), v3(3)
    REAL :: r1d(3), r2d(3), v1d(3), v2d(3), v3d(3)
    REAL :: uinfcr1(3), uinfcr2(3), r1cr2(3)
    REAL :: uinfcr1d(3), uinfcr2d(3), r1cr2d(3)
    REAL :: r1m, r2m, uinfdr1, uinfdr2, r1dr2, den
    REAL :: r1md, r2md, uinfdr1d, uinfdr2d, r1dr2d, dend
    INTRINSIC ABS
    REAL :: abs0
    REAL, DIMENSION(3) :: dummyzerodiffd
    REAL, DIMENSION(3) :: dummyzerodiffd0
    REAL, DIMENSION(3) :: dummyzerodiffd1
    REAL, DIMENSION(3) :: dummyzerodiffd2
    REAL :: temp
    REAL, DIMENSION(3) :: temp0
! EXECUTION
! Compute vectors between the kinks and the point of interest
    r1d = xpd - x1d
    r1 = xp - x1
    r2d = xpd - x2d
    r2 = xp - x2
! Compute the magnitude of these vectors
    CALL NORM_D(r1, r1d, r1m, r1md)
    CALL NORM_D(r2, r2d, r2m, r2md)
! Compute cross products
    uinfcr1d = 0.0
    dummyzerodiffd = 0.0
    CALL CROSS_D(uinf, dummyzerodiffd, r1, r1d, uinfcr1, uinfcr1d)
    uinfcr2d = 0.0
    dummyzerodiffd0 = 0.0
    CALL CROSS_D(uinf, dummyzerodiffd0, r2, r2d, uinfcr2, uinfcr2d)
    r1cr2d = 0.0
    CALL CROSS_D(r1, r1d, r2, r2d, r1cr2, r1cr2d)
! Compute dot products
    dummyzerodiffd1 = 0.0
    CALL DOT_D(uinf, dummyzerodiffd1, r1, r1d, uinfdr1, uinfdr1d)
    dummyzerodiffd2 = 0.0
    CALL DOT_D(uinf, dummyzerodiffd2, r2, r2d, uinfdr2, uinfdr2d)
    CALL DOT_D(r1, r1d, r2, r2d, r1dr2, r1dr2d)
! Compute contributions of each vortex segment
    temp = r2m*(r2m-uinfdr2)
    v1d = (uinfcr2d-uinfcr2*((r2m-uinfdr2)*r2md+r2m*(r2md-uinfdr2d))/&
&     temp)/temp
    v1 = uinfcr2/temp
    dend = r2m*r1md + r1m*r2md + r1dr2d
    den = r1m*r2m + r1dr2
    IF (den .GE. 0.) THEN
      abs0 = den
    ELSE
      abs0 = -den
    END IF
    IF (abs0 .GT. eps) THEN
      temp = r1m*r2m*den
      temp0 = (r1m+r2m)*r1cr2/temp
      v2d = (r1cr2*(r1md+r2md)+(r1m+r2m)*r1cr2d-temp0*(den*(r2m*r1md+r1m&
&       *r2md)+r1m*r2m*dend))/temp
      v2 = temp0
    ELSE
! Bound vortex induces no velocity along its length
      v2 = zero
      v2d = 0.0
    END IF
    temp = r1m*(r1m-uinfdr1)
    v3d = -((uinfcr1d-uinfcr1*((r1m-uinfdr1)*r1md+r1m*(r1md-uinfdr1d))/&
&     temp)/temp)
    v3 = -(uinfcr1/temp)
! Compute overall induced velocity (without the circulation: V/gamma)
    gamma_indd = 0.25*(v1d+v2d+v3d)/pi
    gamma_ind = 0.25*(v1+v2+v3)/pi
  END SUBROUTINE INDUCED_VEL_D

!  Differentiation of induced_vel in reverse (adjoint) mode:
!   gradient     of useful results: xp gamma_ind
!   with respect to varying inputs: xp x1 x2
  SUBROUTINE INDUCED_VEL_B(uinf, x1, x1b, x2, x2b, xp, xpb, gamma_ind, &
&   gamma_indb)
    IMPLICIT NONE
! Input variables
    REAL, INTENT(IN) :: uinf(3), x1(3), x2(3), xp(3)
    REAL :: x1b(3), x2b(3), xpb(3)
! Output variables
    REAL :: gamma_ind(3)
    REAL :: gamma_indb(3)
! Working variables
    REAL :: r1(3), r2(3), v1(3), v2(3), v3(3)
    REAL :: r1b(3), r2b(3), v1b(3), v2b(3), v3b(3)
    REAL :: uinfcr1(3), uinfcr2(3), r1cr2(3)
    REAL :: uinfcr1b(3), uinfcr2b(3), r1cr2b(3)
    REAL :: r1m, r2m, uinfdr1, uinfdr2, r1dr2, den
    REAL :: r1mb, r2mb, uinfdr1b, uinfdr2b, r1dr2b, denb
    INTRINSIC ABS
    REAL :: abs0
    REAL :: temp
    REAL :: tempb
    REAL, DIMENSION(3) :: tempb0
    REAL :: temp0
    REAL :: tempb1
    INTEGER :: branch
    REAL :: uinfb(3)
! EXECUTION
! Compute vectors between the kinks and the point of interest
    r1 = xp - x1
    r2 = xp - x2
! Compute the magnitude of these vectors
    CALL NORM(r1, r1m)
    CALL NORM(r2, r2m)
! Compute cross products
    CALL CROSS(uinf, r1, uinfcr1)
    CALL CROSS(uinf, r2, uinfcr2)
    CALL CROSS(r1, r2, r1cr2)
! Compute dot products
    CALL DOT(uinf, r1, uinfdr1)
    CALL DOT(uinf, r2, uinfdr2)
    CALL DOT(r1, r2, r1dr2)
! Compute contributions of each vortex segment
    v1 = uinfcr2/r2m/(r2m-uinfdr2)
    den = r1m*r2m + r1dr2
    IF (den .GE. 0.) THEN
      abs0 = den
      CALL PUSHCONTROL1B(0)
    ELSE
      abs0 = -den
      CALL PUSHCONTROL1B(1)
    END IF
    IF (abs0 .GT. eps) THEN
      v2 = (r1m+r2m)*r1cr2/r1m/r2m/den
      CALL PUSHCONTROL1B(0)
    ELSE
! Bound vortex induces no velocity along its length
      v2 = zero
      CALL PUSHCONTROL1B(1)
    END IF
    v3 = -(uinfcr1/r1m/(r1m-uinfdr1))
! Compute overall induced velocity (without the circulation: V/gamma)
    gamma_ind = 0.25*(v1+v2+v3)/pi
    v1b = 0.0
    v2b = 0.0
    v3b = 0.0
    tempb0 = 0.25*gamma_indb/pi
    v1b = tempb0
    v2b = tempb0
    v3b = tempb0
    uinfcr1b = 0.0
    temp0 = r1m*(r1m-uinfdr1)
    uinfcr1b = -(v3b/temp0)
    tempb1 = SUM(uinfcr1*v3b)/temp0**2
    r1mb = (2*r1m-uinfdr1)*tempb1
    uinfdr1b = -(r1m*tempb1)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      r1cr2b = 0.0
      temp = r1m*r2m*den
      tempb0 = v2b/temp
      tempb1 = SUM(r1cr2*tempb0)
      r1cr2b = (r1m+r2m)*tempb0
      tempb = -(SUM(r1cr2*tempb0)*(r1m+r2m)/temp)
      r1mb = r1mb + r2m*den*tempb + tempb1
      r2mb = r1m*den*tempb + tempb1
      denb = r1m*r2m*tempb
    ELSE
      r2mb = 0.0
      denb = 0.0
      r1cr2b = 0.0
    END IF
    CALL POPCONTROL1B(branch)
    temp = r2m*(r2m-uinfdr2)
    tempb = -(SUM(uinfcr2*v1b)/temp**2)
    r1mb = r1mb + r2m*denb
    r2mb = r2mb + r1m*denb + (2*r2m-uinfdr2)*tempb
    r1dr2b = denb
    uinfcr2b = 0.0
    uinfcr2b = v1b/temp
    uinfdr2b = -(r2m*tempb)
    r1b = 0.0
    r2b = 0.0
    CALL DOT_B(r1, r1b, r2, r2b, r1dr2, r1dr2b)
    uinfb = 0.0
    CALL DOT_B(uinf, uinfb, r2, r2b, uinfdr2, uinfdr2b)
    uinfb = 0.0
    CALL DOT_B(uinf, uinfb, r1, r1b, uinfdr1, uinfdr1b)
    CALL CROSS_B(r1, r1b, r2, r2b, r1cr2, r1cr2b)
    uinfb = 0.0
    CALL CROSS_B(uinf, uinfb, r2, r2b, uinfcr2, uinfcr2b)
    uinfb = 0.0
    CALL CROSS_B(uinf, uinfb, r1, r1b, uinfcr1, uinfcr1b)
    CALL NORM_B(r2, r2b, r2m, r2mb)
    CALL NORM_B(r1, r1b, r1m, r1mb)
    x2b = 0.0
    xpb = xpb + r2b + r1b
    x2b = -r2b
    x1b = 0.0
    x1b = -r1b
  END SUBROUTINE INDUCED_VEL_B

  SUBROUTINE INDUCED_VEL(uinf, x1, x2, xp, gamma_ind)
    IMPLICIT NONE
! Input variables
    REAL, INTENT(IN) :: uinf(3), x1(3), x2(3), xp(3)
! Output variables
    REAL, INTENT(OUT) :: gamma_ind(3)
! Working variables
    REAL :: r1(3), r2(3), v1(3), v2(3), v3(3)
    REAL :: uinfcr1(3), uinfcr2(3), r1cr2(3)
    REAL :: r1m, r2m, uinfdr1, uinfdr2, r1dr2, den
    INTRINSIC ABS
    REAL :: abs0
! EXECUTION
! Compute vectors between the kinks and the point of interest
    r1 = xp - x1
    r2 = xp - x2
! Compute the magnitude of these vectors
    CALL NORM(r1, r1m)
    CALL NORM(r2, r2m)
! Compute cross products
    CALL CROSS(uinf, r1, uinfcr1)
    CALL CROSS(uinf, r2, uinfcr2)
    CALL CROSS(r1, r2, r1cr2)
! Compute dot products
    CALL DOT(uinf, r1, uinfdr1)
    CALL DOT(uinf, r2, uinfdr2)
    CALL DOT(r1, r2, r1dr2)
! Compute contributions of each vortex segment
    v1 = uinfcr2/r2m/(r2m-uinfdr2)
    den = r1m*r2m + r1dr2
    IF (den .GE. 0.) THEN
      abs0 = den
    ELSE
      abs0 = -den
    END IF
    IF (abs0 .GT. eps) THEN
      v2 = (r1m+r2m)*r1cr2/r1m/r2m/den
    ELSE
! Bound vortex induces no velocity along its length
      v2 = zero
    END IF
    v3 = -(uinfcr1/r1m/(r1m-uinfdr1))
! Compute overall induced velocity (without the circulation: V/gamma)
    gamma_ind = 0.25*(v1+v2+v3)/pi
  END SUBROUTINE INDUCED_VEL

!  Differentiation of get_aic_matrix in forward (tangent) mode:
!   variations   of useful results: aic
!   with respect to varying inputs: x
!============================================================
  SUBROUTINE GET_AIC_MATRIX_D(n_vort, x, xd, uinf, aic, aicd)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: x(3, n_vort+1)
    REAL, INTENT(IN) :: xd(3, n_vort+1)
    REAL, INTENT(IN) :: uinf(3)
! Output variables
    REAL, INTENT(OUT) :: aic(3, n_vort, n_vort)
    REAL, INTENT(OUT) :: aicd(3, n_vort, n_vort)
! Working variables
    INTEGER :: ii, jj
    REAL :: x1(3), x2(3), xcen(3), gamma_ind(3), ni(3)
    REAL :: x1d(3), x2d(3), xcend(3), gamma_indd(3)
    REAL :: nim, sim
    aicd = 0.0
! EXECUTION
! Loop over all vortices
    DO ii=1,n_vort
! Get kink coordinates of the current vortex
      x1d = xd(:, ii)
      x1 = x(:, ii)
      x2d = xd(:, ii+1)
      x2 = x(:, ii+1)
! Compute the center of the bound vortex
      xcend = 0.5*(x1d+x2d)
      xcen = 0.5*(x1+x2)
! Loop over all bound vortices to compute the influence coefficients
      DO jj=1,n_vort
! Get kink coordinates of the current vortex
        x1d = xd(:, jj)
        x1 = x(:, jj)
        x2d = xd(:, jj+1)
        x2 = x(:, jj+1)
! The induced velocity, normalized by gamma, is the influence
! coefficient.
        CALL INDUCED_VEL_D(uinf, x1, x1d, x2, x2d, xcen, xcend, &
&                    gamma_ind, gamma_indd)
        aicd(:, jj, ii) = gamma_indd
        aic(:, jj, ii) = gamma_ind
      END DO
    END DO
  END SUBROUTINE GET_AIC_MATRIX_D

!  Differentiation of get_aic_matrix in reverse (adjoint) mode:
!   gradient     of useful results: x aic
!   with respect to varying inputs: x
!============================================================
  SUBROUTINE GET_AIC_MATRIX_B(n_vort, x, xb, uinf, aic, aicb)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: x(3, n_vort+1)
    REAL :: xb(3, n_vort+1)
    REAL, INTENT(IN) :: uinf(3)
! Output variables
    REAL :: aic(3, n_vort, n_vort)
    REAL :: aicb(3, n_vort, n_vort)
! Working variables
    INTEGER :: ii, jj
    REAL :: x1(3), x2(3), xcen(3), gamma_ind(3), ni(3)
    REAL :: x1b(3), x2b(3), xcenb(3), gamma_indb(3)
    REAL :: nim, sim
! EXECUTION
! Loop over all vortices
    DO ii=1,n_vort
! Get kink coordinates of the current vortex
      CALL PUSHREAL4ARRAY(x1, 3)
      x1 = x(:, ii)
      CALL PUSHREAL4ARRAY(x2, 3)
      x2 = x(:, ii+1)
! Compute the center of the bound vortex
      CALL PUSHREAL4ARRAY(xcen, 3)
      xcen = 0.5*(x1+x2)
! Loop over all bound vortices to compute the influence coefficients
      DO jj=1,n_vort
! Get kink coordinates of the current vortex
        CALL PUSHREAL4ARRAY(x1, 3)
        x1 = x(:, jj)
        CALL PUSHREAL4ARRAY(x2, 3)
        x2 = x(:, jj+1)
! The induced velocity, normalized by gamma, is the influence
! coefficient.
        CALL INDUCED_VEL(uinf, x1, x2, xcen, gamma_ind)
        aic(:, jj, ii) = gamma_ind
      END DO
    END DO
    DO ii=n_vort,1,-1
      xcenb = 0.0
      DO jj=n_vort,1,-1
        gamma_indb = 0.0
        gamma_indb = aicb(:, jj, ii)
        aicb(:, jj, ii) = 0.0
        CALL INDUCED_VEL_B(uinf, x1, x1b, x2, x2b, xcen, xcenb, &
&                    gamma_ind, gamma_indb)
        CALL POPREAL4ARRAY(x2, 3)
        xb(:, jj+1) = xb(:, jj+1) + x2b
        CALL POPREAL4ARRAY(x1, 3)
        xb(:, jj) = xb(:, jj) + x1b
      END DO
      x1b = 0.0
      x2b = 0.0
      CALL POPREAL4ARRAY(xcen, 3)
      x1b = 0.5*xcenb
      x2b = 0.5*xcenb
      CALL POPREAL4ARRAY(x2, 3)
      xb(:, ii+1) = xb(:, ii+1) + x2b
      CALL POPREAL4ARRAY(x1, 3)
      xb(:, ii) = xb(:, ii) + x1b
    END DO
  END SUBROUTINE GET_AIC_MATRIX_B

!============================================================
  SUBROUTINE GET_AIC_MATRIX(n_vort, x, uinf, aic)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: x(3, n_vort+1)
    REAL, INTENT(IN) :: uinf(3)
! Output variables
    REAL, INTENT(OUT) :: aic(3, n_vort, n_vort)
! Working variables
    INTEGER :: ii, jj
    REAL :: x1(3), x2(3), xcen(3), gamma_ind(3), ni(3)
    REAL :: nim, sim
! EXECUTION
! Loop over all vortices
    DO ii=1,n_vort
! Get kink coordinates of the current vortex
      x1 = x(:, ii)
      x2 = x(:, ii+1)
! Compute the center of the bound vortex
      xcen = 0.5*(x1+x2)
! Loop over all bound vortices to compute the influence coefficients
      DO jj=1,n_vort
! Get kink coordinates of the current vortex
        x1 = x(:, jj)
        x2 = x(:, jj+1)
! The induced velocity, normalized by gamma, is the influence
! coefficient.
        CALL INDUCED_VEL(uinf, x1, x2, xcen, gamma_ind)
        aic(:, jj, ii) = gamma_ind
      END DO
    END DO
  END SUBROUTINE GET_AIC_MATRIX

!  Differentiation of get_geom_vectors in forward (tangent) mode:
!   variations   of useful results: uai uni si areas
!   with respect to varying inputs: alpha0 x
!============================================================
  SUBROUTINE GET_GEOM_VECTORS_D(n_vort, x, xd, alpha0, alpha0d, chords, &
&   uai, uaid, uni, unid, si, sid, areas, areasd)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: x(3, n_vort+1)
    REAL, INTENT(IN) :: xd(3, n_vort+1)
    REAL, INTENT(IN) :: alpha0(n_vort), chords(n_vort)
    REAL, INTENT(IN) :: alpha0d(n_vort)
! Output variables
    REAL, INTENT(OUT) :: uai(3, n_vort), uni(3, n_vort)
    REAL, INTENT(OUT) :: uaid(3, n_vort), unid(3, n_vort)
    REAL, INTENT(OUT) :: si(3, n_vort), areas(n_vort)
    REAL, INTENT(OUT) :: sid(3, n_vort), areasd(n_vort)
! Working variables
    INTEGER :: ii
    REAL :: x1(3), x2(3), usi(3), ni(3)
    REAL :: x1d(3), x2d(3), usid(3), nid(3)
    REAL :: nim, sim
    REAL :: nimd, simd
    INTRINSIC COS
    INTRINSIC SIN
    uaid = 0.0
    unid = 0.0
    sid = 0.0
    areasd = 0.0
    nid = 0.0
! EXECUTION
! Loop over all vortices
    DO ii=1,n_vort
! Get kink coordinates of the current vortex
      x1d = xd(:, ii)
      x1 = x(:, ii)
      x2d = xd(:, ii+1)
      x2 = x(:, ii+1)
! Compute the vector along the local span
      sid(:, ii) = x2d - x1d
      si(:, ii) = x2 - x1
      CALL NORMALIZE_D(si(:, ii), sid(:, ii), usi, usid)
! Create a unitary vector along the chordline
! pointing to the trailing edge
      uaid(1, ii) = -(SIN(alpha0(ii))*alpha0d(ii))
      uai(1, ii) = COS(alpha0(ii))
      uaid(2, ii) = 0.0
      uai(2, ii) = zero
      uaid(3, ii) = -(COS(alpha0(ii))*alpha0d(ii))
      uai(3, ii) = -SIN(alpha0(ii))
! Get the normal vector as the normal between the span
! and the chord vector
      CALL CROSS_D(uai(:, ii), uaid(:, ii), usi, usid, ni, nid)
      CALL NORMALIZE_D(ni, nid, uni(:, ii), unid(:, ii))
! Compute the local area of the panel.
! The norm of the normal vector is the sine of the angle.
      CALL NORM_D(ni, nid, nim, nimd)
      CALL NORM_D(si(:, ii), sid(:, ii), sim, simd)
      areasd(ii) = chords(ii)*(sim*nimd+nim*simd)
      areas(ii) = nim*chords(ii)*sim
    END DO
  END SUBROUTINE GET_GEOM_VECTORS_D

!  Differentiation of get_geom_vectors in reverse (adjoint) mode:
!   gradient     of useful results: alpha0 x uai uni si areas
!   with respect to varying inputs: alpha0 x
!============================================================
  SUBROUTINE GET_GEOM_VECTORS_B(n_vort, x, xb, alpha0, alpha0b, chords, &
&   uai, uaib, uni, unib, si, sib, areas, areasb)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: x(3, n_vort+1)
    REAL :: xb(3, n_vort+1)
    REAL, INTENT(IN) :: alpha0(n_vort), chords(n_vort)
    REAL :: alpha0b(n_vort)
! Output variables
    REAL :: uai(3, n_vort), uni(3, n_vort)
    REAL :: uaib(3, n_vort), unib(3, n_vort)
    REAL :: si(3, n_vort), areas(n_vort)
    REAL :: sib(3, n_vort), areasb(n_vort)
! Working variables
    INTEGER :: ii
    REAL :: x1(3), x2(3), usi(3), ni(3)
    REAL :: x1b(3), x2b(3), usib(3), nib(3)
    REAL :: nim, sim
    REAL :: nimb, simb
    INTRINSIC COS
    INTRINSIC SIN
! EXECUTION
! Loop over all vortices
    DO ii=1,n_vort
! Get kink coordinates of the current vortex
      x1 = x(:, ii)
      x2 = x(:, ii+1)
! Compute the vector along the local span
      si(:, ii) = x2 - x1
      CALL PUSHREAL4ARRAY(usi, 3)
      CALL NORMALIZE(si(:, ii), usi)
! Create a unitary vector along the chordline
! pointing to the trailing edge
      uai(1, ii) = COS(alpha0(ii))
      uai(2, ii) = zero
      uai(3, ii) = -SIN(alpha0(ii))
! Get the normal vector as the normal between the span
! and the chord vector
      CALL PUSHREAL4ARRAY(ni, 3)
      CALL CROSS(uai(:, ii), usi, ni)
      CALL NORMALIZE(ni, uni(:, ii))
! Compute the local area of the panel.
! The norm of the normal vector is the sine of the angle.
      CALL PUSHREAL4(nim)
      CALL NORM(ni, nim)
      CALL PUSHREAL4(sim)
      CALL NORM(si(:, ii), sim)
      areas(ii) = nim*chords(ii)*sim
    END DO
    nib = 0.0
    DO ii=n_vort,1,-1
      nimb = sim*chords(ii)*areasb(ii)
      simb = nim*chords(ii)*areasb(ii)
      areasb(ii) = 0.0
      CALL POPREAL4(sim)
      CALL NORM_B(si(:, ii), sib(:, ii), sim, simb)
      CALL POPREAL4(nim)
      CALL NORM_B(ni, nib, nim, nimb)
      CALL NORMALIZE_B(ni, nib, uni(:, ii), unib(:, ii))
      unib(:, ii) = 0.0
      CALL POPREAL4ARRAY(ni, 3)
      usib = 0.0
      CALL CROSS_B(uai(:, ii), uaib(:, ii), usi, usib, ni, nib)
      alpha0b(ii) = alpha0b(ii) - COS(alpha0(ii))*uaib(3, ii) - SIN(&
&       alpha0(ii))*uaib(1, ii)
      uaib(3, ii) = 0.0
      uaib(2, ii) = 0.0
      uaib(1, ii) = 0.0
      CALL POPREAL4ARRAY(usi, 3)
      CALL NORMALIZE_B(si(:, ii), sib(:, ii), usi, usib)
      x1b = 0.0
      x2b = 0.0
      x2b = sib(:, ii)
      x1b = -sib(:, ii)
      sib(:, ii) = 0.0
      xb(:, ii+1) = xb(:, ii+1) + x2b
      xb(:, ii) = xb(:, ii) + x1b
    END DO
  END SUBROUTINE GET_GEOM_VECTORS_B

!============================================================
  SUBROUTINE GET_GEOM_VECTORS(n_vort, x, alpha0, chords, uai, uni, si, &
&   areas)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: x(3, n_vort+1)
    REAL, INTENT(IN) :: alpha0(n_vort), chords(n_vort)
! Output variables
    REAL, INTENT(OUT) :: uai(3, n_vort), uni(3, n_vort)
    REAL, INTENT(OUT) :: si(3, n_vort), areas(n_vort)
! Working variables
    INTEGER :: ii
    REAL :: x1(3), x2(3), usi(3), ni(3)
    REAL :: nim, sim
    INTRINSIC COS
    INTRINSIC SIN
! EXECUTION
! Loop over all vortices
    DO ii=1,n_vort
! Get kink coordinates of the current vortex
      x1 = x(:, ii)
      x2 = x(:, ii+1)
! Compute the vector along the local span
      si(:, ii) = x2 - x1
      CALL NORMALIZE(si(:, ii), usi)
! Create a unitary vector along the chordline
! pointing to the trailing edge
      uai(1, ii) = COS(alpha0(ii))
      uai(2, ii) = zero
      uai(3, ii) = -SIN(alpha0(ii))
! Get the normal vector as the normal between the span
! and the chord vector
      CALL CROSS(uai(:, ii), usi, ni)
      CALL NORMALIZE(ni, uni(:, ii))
! Compute the local area of the panel.
! The norm of the normal vector is the sine of the angle.
      CALL NORM(ni, nim)
      CALL NORM(si(:, ii), sim)
      areas(ii) = nim*chords(ii)*sim
    END DO
  END SUBROUTINE GET_GEOM_VECTORS

!  Differentiation of get_local_vels in forward (tangent) mode:
!   variations   of useful results: vlocal alphalocal
!   with respect to varying inputs: uai uni gama aic
!============================================================
  SUBROUTINE GET_LOCAL_VELS_D(n_vort, gama, gamad, aic, aicd, vinf, uai&
&   , uaid, uni, unid, vlocal, vlocald, alphalocal, alphalocald)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: gama(n_vort), aic(3, n_vort, n_vort)
    REAL, INTENT(IN) :: gamad(n_vort), aicd(3, n_vort, n_vort)
    REAL, INTENT(IN) :: vinf(3), uai(3, n_vort), uni(3, n_vort)
    REAL, INTENT(IN) :: uaid(3, n_vort), unid(3, n_vort)
! Output variables
    REAL, INTENT(OUT) :: vlocal(3, n_vort), alphalocal(n_vort)
    REAL, INTENT(OUT) :: vlocald(3, n_vort), alphalocald(n_vort)
! Working variables
    INTEGER :: ii, jj
    REAL :: num, den
    REAL :: numd, dend
    INTRINSIC ATAN
    REAL :: temp
    vlocald = 0.0
    alphalocald = 0.0
! EXECUTION
! Do the matrix operation
    DO ii=1,n_vort
! Start with the free-strem contribution
      vlocald(:, ii) = 0.0
      vlocal(:, ii) = vinf
! Now add the velocities induced by each vortex
      DO jj=1,n_vort
        vlocald(:, ii) = vlocald(:, ii) + gama(jj)*aicd(:, jj, ii) + aic&
&         (:, jj, ii)*gamad(jj)
        vlocal(:, ii) = vlocal(:, ii) + aic(:, jj, ii)*gama(jj)
      END DO
! Compute the local angle of attack
      CALL DOT_D(vlocal(:, ii), vlocald(:, ii), uni(:, ii), unid(:, ii)&
&          , num, numd)
      CALL DOT_D(vlocal(:, ii), vlocald(:, ii), uai(:, ii), uaid(:, ii)&
&          , den, dend)
      temp = num/den
      alphalocald(ii) = (numd-temp*dend)/((1.0+temp**2)*den)
      alphalocal(ii) = ATAN(temp)
    END DO
  END SUBROUTINE GET_LOCAL_VELS_D

!  Differentiation of get_local_vels in reverse (adjoint) mode:
!   gradient     of useful results: vlocal gama alphalocal
!   with respect to varying inputs: uai uni gama aic
!============================================================
  SUBROUTINE GET_LOCAL_VELS_B(n_vort, gama, gamab, aic, aicb, vinf, uai&
&   , uaib, uni, unib, vlocal, vlocalb, alphalocal, alphalocalb)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: gama(n_vort), aic(3, n_vort, n_vort)
    REAL :: gamab(n_vort), aicb(3, n_vort, n_vort)
    REAL, INTENT(IN) :: vinf(3), uai(3, n_vort), uni(3, n_vort)
    REAL :: uaib(3, n_vort), unib(3, n_vort)
! Output variables
    REAL :: vlocal(3, n_vort), alphalocal(n_vort)
    REAL :: vlocalb(3, n_vort), alphalocalb(n_vort)
! Working variables
    INTEGER :: ii, jj
    REAL :: num, den
    REAL :: numb, denb
    INTRINSIC ATAN
    REAL :: tempb
! EXECUTION
! Do the matrix operation
    DO ii=1,n_vort
! Start with the free-strem contribution
      vlocal(:, ii) = vinf
! Now add the velocities induced by each vortex
      DO jj=1,n_vort
        vlocal(:, ii) = vlocal(:, ii) + aic(:, jj, ii)*gama(jj)
      END DO
! Compute the local angle of attack
      CALL PUSHREAL4(num)
      CALL DOT(vlocal(:, ii), uni(:, ii), num)
      CALL PUSHREAL4(den)
      CALL DOT(vlocal(:, ii), uai(:, ii), den)
      alphalocal(ii) = ATAN(num/den)
    END DO
    uaib = 0.0
    unib = 0.0
    aicb = 0.0
    DO ii=n_vort,1,-1
      tempb = alphalocalb(ii)/(den*(1.0+(num/den)**2))
      alphalocalb(ii) = 0.0
      numb = tempb
      denb = -(num*tempb/den)
      CALL POPREAL4(den)
      CALL DOT_B(vlocal(:, ii), vlocalb(:, ii), uai(:, ii), uaib(:, ii)&
&          , den, denb)
      CALL POPREAL4(num)
      CALL DOT_B(vlocal(:, ii), vlocalb(:, ii), uni(:, ii), unib(:, ii)&
&          , num, numb)
      DO jj=n_vort,1,-1
        aicb(:, jj, ii) = aicb(:, jj, ii) + gama(jj)*vlocalb(:, ii)
        gamab(jj) = gamab(jj) + SUM(aic(:, jj, ii)*vlocalb(:, ii))
      END DO
      vlocalb(:, ii) = 0.0
    END DO
  END SUBROUTINE GET_LOCAL_VELS_B

!============================================================
  SUBROUTINE GET_LOCAL_VELS(n_vort, gama, aic, vinf, uai, uni, vlocal, &
&   alphalocal)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: gama(n_vort), aic(3, n_vort, n_vort)
    REAL, INTENT(IN) :: vinf(3), uai(3, n_vort), uni(3, n_vort)
! Output variables
    REAL, INTENT(OUT) :: vlocal(3, n_vort), alphalocal(n_vort)
! Working variables
    INTEGER :: ii, jj
    REAL :: num, den
    INTRINSIC ATAN
! EXECUTION
! Do the matrix operation
    DO ii=1,n_vort
! Start with the free-strem contribution
      vlocal(:, ii) = vinf
! Now add the velocities induced by each vortex
      DO jj=1,n_vort
        vlocal(:, ii) = vlocal(:, ii) + aic(:, jj, ii)*gama(jj)
      END DO
! Compute the local angle of attack
      CALL DOT(vlocal(:, ii), uni(:, ii), num)
      CALL DOT(vlocal(:, ii), uai(:, ii), den)
      alphalocal(ii) = ATAN(num/den)
    END DO
  END SUBROUTINE GET_LOCAL_VELS

!  Differentiation of compute_circulation_forces in forward (tangent) mode:
!   variations   of useful results: fcirc
!   with respect to varying inputs: vlocal gama si
!============================================================
  SUBROUTINE COMPUTE_CIRCULATION_FORCES_D(n_vort, rho, vlocal, vlocald, &
&   si, sid, gama, gamad, fcirc, fcircd)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: rho, vlocal(3, n_vort), si(3, n_vort)
    REAL, INTENT(IN) :: vlocald(3, n_vort), sid(3, n_vort)
    REAL, INTENT(IN) :: gama(n_vort)
    REAL, INTENT(IN) :: gamad(n_vort)
! Output variables
    REAL, INTENT(OUT) :: fcirc(3, n_vort)
    REAL, INTENT(OUT) :: fcircd(3, n_vort)
! Working variables
    INTEGER :: ii
    REAL :: li(3)
    REAL :: lid(3)
    fcircd = 0.0
    lid = 0.0
! EXECUTION
    DO ii=1,n_vort
! L=rho*V*gamma*l
      CALL CROSS_D(vlocal(:, ii), vlocald(:, ii), si(:, ii), sid(:, ii)&
&            , li, lid)
      fcircd(:, ii) = rho*(li*gamad(ii)+gama(ii)*lid)
      fcirc(:, ii) = rho*gama(ii)*li
    END DO
  END SUBROUTINE COMPUTE_CIRCULATION_FORCES_D

!  Differentiation of compute_circulation_forces in reverse (adjoint) mode:
!   gradient     of useful results: vlocal gama si fcirc
!   with respect to varying inputs: vlocal gama si
!============================================================
  SUBROUTINE COMPUTE_CIRCULATION_FORCES_B(n_vort, rho, vlocal, vlocalb, &
&   si, sib, gama, gamab, fcirc, fcircb)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: rho, vlocal(3, n_vort), si(3, n_vort)
    REAL :: vlocalb(3, n_vort), sib(3, n_vort)
    REAL, INTENT(IN) :: gama(n_vort)
    REAL :: gamab(n_vort)
! Output variables
    REAL :: fcirc(3, n_vort)
    REAL :: fcircb(3, n_vort)
! Working variables
    INTEGER :: ii
    REAL :: li(3)
    REAL :: lib(3)
! EXECUTION
    DO ii=1,n_vort
! L=rho*V*gamma*l
      CALL PUSHREAL4ARRAY(li, 3)
      CALL CROSS(vlocal(:, ii), si(:, ii), li)
      fcirc(:, ii) = rho*gama(ii)*li
    END DO
    lib = 0.0
    DO ii=n_vort,1,-1
      gamab(ii) = gamab(ii) + SUM(li*fcircb(:, ii))*rho
      lib = lib + gama(ii)*rho*fcircb(:, ii)
      fcircb(:, ii) = 0.0
      CALL POPREAL4ARRAY(li, 3)
      CALL CROSS_B(vlocal(:, ii), vlocalb(:, ii), si(:, ii), sib(:, ii)&
&            , li, lib)
    END DO
  END SUBROUTINE COMPUTE_CIRCULATION_FORCES_B

!============================================================
  SUBROUTINE COMPUTE_CIRCULATION_FORCES(n_vort, rho, vlocal, si, gama, &
&   fcirc)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: rho, vlocal(3, n_vort), si(3, n_vort)
    REAL, INTENT(IN) :: gama(n_vort)
! Output variables
    REAL, INTENT(OUT) :: fcirc(3, n_vort)
! Working variables
    INTEGER :: ii
    REAL :: li(3)
! EXECUTION
    DO ii=1,n_vort
! L=rho*V*gamma*l
      CALL CROSS(vlocal(:, ii), si(:, ii), li)
      fcirc(:, ii) = rho*gama(ii)*li
    END DO
  END SUBROUTINE COMPUTE_CIRCULATION_FORCES

!  Differentiation of compute_airfoil_forces in forward (tangent) mode:
!   variations   of useful results: fairf
!   with respect to varying inputs: vlocal si areas alphalocal
!============================================================
  SUBROUTINE COMPUTE_AIRFOIL_FORCES_D(n_vort, rho, cl0, cla, areas, &
&   areasd, vlocal, vlocald, alphalocal, alphalocald, si, sid, fairf, &
&   fairfd)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: rho, cl0(n_vort), cla(n_vort), areas(n_vort)
    REAL, INTENT(IN) :: areasd(n_vort)
    REAL, INTENT(IN) :: vlocal(3, n_vort), alphalocal(n_vort), si(3, &
&   n_vort)
    REAL, INTENT(IN) :: vlocald(3, n_vort), alphalocald(n_vort), sid(3, &
&   n_vort)
! Output variables
    REAL, INTENT(OUT) :: fairf(3, n_vort)
    REAL, INTENT(OUT) :: fairfd(3, n_vort)
! Working variables
    REAL :: fairfm, cl, li(3), uli(3), vlocalm
    REAL :: fairfmd, cld, lid(3), ulid(3), vlocalmd
    INTEGER :: ii
    fairfd = 0.0
    lid = 0.0
! EXECUTION
! Loop over all horseshoe vortices
    DO ii=1,n_vort
! Compute the magnitude of the force given by the 2D section
! L = 0.5*Vlocal²*area*cl
      cld = cla(ii)*alphalocald(ii)
      cl = cl0(ii) + alphalocal(ii)*cla(ii)
      CALL NORM_D(vlocal(:, ii), vlocald(:, ii), vlocalm, vlocalmd)
      fairfmd = rho*0.5*(areas(ii)*cl*2*vlocalm*vlocalmd+vlocalm**2*(cl*&
&       areasd(ii)+areas(ii)*cld))
      fairfm = 0.5*rho*vlocalm*vlocalm*areas(ii)*cl
! Get normalized lift direction
      CALL CROSS_D(vlocal(:, ii), vlocald(:, ii), si(:, ii), sid(:, ii)&
&            , li, lid)
      CALL NORMALIZE_D(li, lid, uli, ulid)
! Store the force
      fairfd(:, ii) = uli*fairfmd + fairfm*ulid
      fairf(:, ii) = fairfm*uli
    END DO
  END SUBROUTINE COMPUTE_AIRFOIL_FORCES_D

!  Differentiation of compute_airfoil_forces in reverse (adjoint) mode:
!   gradient     of useful results: fairf
!   with respect to varying inputs: vlocal si areas alphalocal
!============================================================
  SUBROUTINE COMPUTE_AIRFOIL_FORCES_B(n_vort, rho, cl0, cla, areas, &
&   areasb, vlocal, vlocalb, alphalocal, alphalocalb, si, sib, fairf, &
&   fairfb)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: rho, cl0(n_vort), cla(n_vort), areas(n_vort)
    REAL :: areasb(n_vort)
    REAL, INTENT(IN) :: vlocal(3, n_vort), alphalocal(n_vort), si(3, &
&   n_vort)
    REAL :: vlocalb(3, n_vort), alphalocalb(n_vort), sib(3, n_vort)
! Output variables
    REAL :: fairf(3, n_vort)
    REAL :: fairfb(3, n_vort)
! Working variables
    REAL :: fairfm, cl, li(3), uli(3), vlocalm
    REAL :: fairfmb, clb, lib(3), ulib(3), vlocalmb
    INTEGER :: ii
    REAL :: tempb
    REAL :: tempb0
! EXECUTION
! Loop over all horseshoe vortices
    DO ii=1,n_vort
! Compute the magnitude of the force given by the 2D section
! L = 0.5*Vlocal²*area*cl
      CALL PUSHREAL4(cl)
      cl = cl0(ii) + alphalocal(ii)*cla(ii)
      CALL PUSHREAL4(vlocalm)
      CALL NORM(vlocal(:, ii), vlocalm)
      CALL PUSHREAL4(fairfm)
      fairfm = 0.5*rho*vlocalm*vlocalm*areas(ii)*cl
! Get normalized lift direction
      CALL PUSHREAL4ARRAY(li, 3)
      CALL CROSS(vlocal(:, ii), si(:, ii), li)
      CALL PUSHREAL4ARRAY(uli, 3)
      CALL NORMALIZE(li, uli)
! Store the force
      fairf(:, ii) = fairfm*uli
    END DO
    vlocalb = 0.0
    sib = 0.0
    areasb = 0.0
    alphalocalb = 0.0
    lib = 0.0
    DO ii=n_vort,1,-1
      ulib = 0.0
      fairfmb = SUM(uli*fairfb(:, ii))
      ulib = fairfm*fairfb(:, ii)
      fairfb(:, ii) = 0.0
      CALL POPREAL4ARRAY(uli, 3)
      CALL NORMALIZE_B(li, lib, uli, ulib)
      CALL POPREAL4ARRAY(li, 3)
      CALL CROSS_B(vlocal(:, ii), vlocalb(:, ii), si(:, ii), sib(:, ii)&
&            , li, lib)
      CALL POPREAL4(fairfm)
      tempb = rho*0.5*fairfmb
      vlocalmb = 2*vlocalm*areas(ii)*cl*tempb
      tempb0 = vlocalm**2*tempb
      areasb(ii) = areasb(ii) + cl*tempb0
      clb = areas(ii)*tempb0
      CALL POPREAL4(vlocalm)
      CALL NORM_B(vlocal(:, ii), vlocalb(:, ii), vlocalm, vlocalmb)
      CALL POPREAL4(cl)
      alphalocalb(ii) = alphalocalb(ii) + cla(ii)*clb
    END DO
  END SUBROUTINE COMPUTE_AIRFOIL_FORCES_B

!============================================================
  SUBROUTINE COMPUTE_AIRFOIL_FORCES(n_vort, rho, cl0, cla, areas, vlocal&
&   , alphalocal, si, fairf)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: rho, cl0(n_vort), cla(n_vort), areas(n_vort)
    REAL, INTENT(IN) :: vlocal(3, n_vort), alphalocal(n_vort), si(3, &
&   n_vort)
! Output variables
    REAL, INTENT(OUT) :: fairf(3, n_vort)
! Working variables
    REAL :: fairfm, cl, li(3), uli(3), vlocalm
    INTEGER :: ii
! EXECUTION
! Loop over all horseshoe vortices
    DO ii=1,n_vort
! Compute the magnitude of the force given by the 2D section
! L = 0.5*Vlocal²*area*cl
      cl = cl0(ii) + alphalocal(ii)*cla(ii)
      CALL NORM(vlocal(:, ii), vlocalm)
      fairfm = 0.5*rho*vlocalm*vlocalm*areas(ii)*cl
! Get normalized lift direction
      CALL CROSS(vlocal(:, ii), si(:, ii), li)
      CALL NORMALIZE(li, uli)
! Store the force
      fairf(:, ii) = fairfm*uli
    END DO
  END SUBROUTINE COMPUTE_AIRFOIL_FORCES

!  Differentiation of get_residuals in forward (tangent) mode:
!   variations   of useful results: res
!   with respect to varying inputs: res alpha0 x gama
!============================================================
  SUBROUTINE GET_RESIDUALS_D(n_vort, x, xd, gama, gamad, alpha0, alpha0d&
&   , chords, cl0, cla, vinf, rho, res, resd)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: x(3, n_vort+1)
    REAL, INTENT(IN) :: xd(3, n_vort+1)
    REAL, INTENT(IN) :: gama(n_vort), alpha0(n_vort)
    REAL, INTENT(IN) :: gamad(n_vort), alpha0d(n_vort)
    REAL, INTENT(IN) :: chords(n_vort), cl0(n_vort)
    REAL, INTENT(IN) :: cla(n_vort), vinf(3), rho
! Output variables
    REAL, INTENT(OUT) :: res(n_vort)
    REAL, INTENT(OUT) :: resd(n_vort)
! Working variables
    INTEGER :: ii
    REAL :: uinf(3), aic(3, n_vort, n_vort)
    REAL :: aicd(3, n_vort, n_vort)
    REAL :: uai(3, n_vort), uni(3, n_vort), si(3, n_vort)
    REAL :: uaid(3, n_vort), unid(3, n_vort), sid(3, n_vort)
    REAL :: areas(n_vort), vlocal(3, n_vort), alphalocal(n_vort)
    REAL :: areasd(n_vort), vlocald(3, n_vort), alphalocald(n_vort)
    REAL :: fcirc(3, n_vort), fairf(3, n_vort), deltaf(3)
    REAL :: fcircd(3, n_vort), fairfd(3, n_vort), deltafd(3)
    INTRINSIC SUM
! EXECUTION
! Normalize free-stream velocity
    CALL NORMALIZE(vinf, uinf)
! Get AIC matrix
    CALL GET_AIC_MATRIX_D(n_vort, x, xd, uinf, aic, aicd)
! Get geometric vectors
    CALL GET_GEOM_VECTORS_D(n_vort, x, xd, alpha0, alpha0d, chords, uai&
&                     , uaid, uni, unid, si, sid, areas, areasd)
! Get induced velocities
    CALL GET_LOCAL_VELS_D(n_vort, gama, gamad, aic, aicd, vinf, uai, &
&                   uaid, uni, unid, vlocal, vlocald, alphalocal, &
&                   alphalocald)
! Get circulation forces
    CALL COMPUTE_CIRCULATION_FORCES_D(n_vort, rho, vlocal, vlocald, si, &
&                               sid, gama, gamad, fcirc, fcircd)
! Get airfoil forces
    CALL COMPUTE_AIRFOIL_FORCES_D(n_vort, rho, cl0, cla, areas, areasd, &
&                           vlocal, vlocald, alphalocal, alphalocald, si&
&                           , sid, fairf, fairfd)
! The residual is the difference between the forces for each horseshoe vortex
    DO ii=1,n_vort
! Get the difference in forces
      deltafd = fcircd(:, ii) - fairfd(:, ii)
      deltaf = fcirc(:, ii) - fairf(:, ii)
! The residual is the magnitude of the difference
      resd(ii) = SUM(2*deltaf*deltafd)
      res(ii) = SUM(deltaf**2)
    END DO
  END SUBROUTINE GET_RESIDUALS_D

!  Differentiation of get_residuals in reverse (adjoint) mode:
!   gradient     of useful results: res alpha0 x gama
!   with respect to varying inputs: res alpha0 x gama
!============================================================
  SUBROUTINE GET_RESIDUALS_B(n_vort, x, xb, gama, gamab, alpha0, alpha0b&
&   , chords, cl0, cla, vinf, rho, res, resb)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: x(3, n_vort+1)
    REAL :: xb(3, n_vort+1)
    REAL, INTENT(IN) :: gama(n_vort), alpha0(n_vort)
    REAL :: gamab(n_vort), alpha0b(n_vort)
    REAL, INTENT(IN) :: chords(n_vort), cl0(n_vort)
    REAL, INTENT(IN) :: cla(n_vort), vinf(3), rho
! Output variables
    REAL :: res(n_vort)
    REAL :: resb(n_vort)
! Working variables
    INTEGER :: ii
    REAL :: uinf(3), aic(3, n_vort, n_vort)
    REAL :: aicb(3, n_vort, n_vort)
    REAL :: uai(3, n_vort), uni(3, n_vort), si(3, n_vort)
    REAL :: uaib(3, n_vort), unib(3, n_vort), sib(3, n_vort)
    REAL :: areas(n_vort), vlocal(3, n_vort), alphalocal(n_vort)
    REAL :: areasb(n_vort), vlocalb(3, n_vort), alphalocalb(n_vort)
    REAL :: fcirc(3, n_vort), fairf(3, n_vort), deltaf(3)
    REAL :: fcircb(3, n_vort), fairfb(3, n_vort), deltafb(3)
    INTRINSIC SUM
! EXECUTION
! Normalize free-stream velocity
    CALL NORMALIZE(vinf, uinf)
! Get AIC matrix
    CALL GET_AIC_MATRIX(n_vort, x, uinf, aic)
! Get geometric vectors
    CALL PUSHREAL4ARRAY(uai, 3*n_vort)
    CALL GET_GEOM_VECTORS(n_vort, x, alpha0, chords, uai, uni, si, areas&
&                  )
! Get induced velocities
    CALL GET_LOCAL_VELS(n_vort, gama, aic, vinf, uai, uni, vlocal, &
&                 alphalocal)
! Get circulation forces
    CALL COMPUTE_CIRCULATION_FORCES(n_vort, rho, vlocal, si, gama, fcirc&
&                            )
! Get airfoil forces
    CALL COMPUTE_AIRFOIL_FORCES(n_vort, rho, cl0, cla, areas, vlocal, &
&                         alphalocal, si, fairf)
! The residual is the difference between the forces for each horseshoe vortex
    DO ii=1,n_vort
! Get the difference in forces
      CALL PUSHREAL4ARRAY(deltaf, 3)
      deltaf = fcirc(:, ii) - fairf(:, ii)
! The residual is the magnitude of the difference
      res(ii) = SUM(deltaf**2)
    END DO
    fairfb = 0.0
    fcircb = 0.0
    DO ii=n_vort,1,-1
      deltafb = 0.0
      deltafb = 2*deltaf*resb(ii)
      resb(ii) = 0.0
      CALL POPREAL4ARRAY(deltaf, 3)
      fcircb(:, ii) = fcircb(:, ii) + deltafb
      fairfb(:, ii) = fairfb(:, ii) - deltafb
    END DO
    CALL COMPUTE_AIRFOIL_FORCES_B(n_vort, rho, cl0, cla, areas, areasb, &
&                           vlocal, vlocalb, alphalocal, alphalocalb, si&
&                           , sib, fairf, fairfb)
    CALL COMPUTE_CIRCULATION_FORCES_B(n_vort, rho, vlocal, vlocalb, si, &
&                               sib, gama, gamab, fcirc, fcircb)
    CALL GET_LOCAL_VELS_B(n_vort, gama, gamab, aic, aicb, vinf, uai, &
&                   uaib, uni, unib, vlocal, vlocalb, alphalocal, &
&                   alphalocalb)
    CALL POPREAL4ARRAY(uai, 3*n_vort)
    CALL GET_GEOM_VECTORS_B(n_vort, x, xb, alpha0, alpha0b, chords, uai&
&                     , uaib, uni, unib, si, sib, areas, areasb)
    CALL GET_AIC_MATRIX_B(n_vort, x, xb, uinf, aic, aicb)
  END SUBROUTINE GET_RESIDUALS_B

!============================================================
  SUBROUTINE GET_RESIDUALS(n_vort, x, gama, alpha0, chords, cl0, cla, &
&   vinf, rho, res)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: x(3, n_vort+1)
    REAL, INTENT(IN) :: gama(n_vort), alpha0(n_vort)
    REAL, INTENT(IN) :: chords(n_vort), cl0(n_vort)
    REAL, INTENT(IN) :: cla(n_vort), vinf(3), rho
! Output variables
    REAL, INTENT(OUT) :: res(n_vort)
! Working variables
    INTEGER :: ii
    REAL :: uinf(3), aic(3, n_vort, n_vort)
    REAL :: uai(3, n_vort), uni(3, n_vort), si(3, n_vort)
    REAL :: areas(n_vort), vlocal(3, n_vort), alphalocal(n_vort)
    REAL :: fcirc(3, n_vort), fairf(3, n_vort), deltaf(3)
    INTRINSIC SUM
! EXECUTION
! Normalize free-stream velocity
    CALL NORMALIZE(vinf, uinf)
! Get AIC matrix
    CALL GET_AIC_MATRIX(n_vort, x, uinf, aic)
! Get geometric vectors
    CALL GET_GEOM_VECTORS(n_vort, x, alpha0, chords, uai, uni, si, areas&
&                  )
! Get induced velocities
    CALL GET_LOCAL_VELS(n_vort, gama, aic, vinf, uai, uni, vlocal, &
&                 alphalocal)
! Get circulation forces
    CALL COMPUTE_CIRCULATION_FORCES(n_vort, rho, vlocal, si, gama, fcirc&
&                            )
! Get airfoil forces
    CALL COMPUTE_AIRFOIL_FORCES(n_vort, rho, cl0, cla, areas, vlocal, &
&                         alphalocal, si, fairf)
! The residual is the difference between the forces for each horseshoe vortex
    DO ii=1,n_vort
! Get the difference in forces
      deltaf = fcirc(:, ii) - fairf(:, ii)
! The residual is the magnitude of the difference
      res(ii) = SUM(deltaf**2)
    END DO
  END SUBROUTINE GET_RESIDUALS

!  Differentiation of get_functions in forward (tangent) mode:
!   variations   of useful results: d loads l sref
!   with respect to varying inputs: alpha0 x gama
!============================================================
  SUBROUTINE GET_FUNCTIONS_D(n_vort, x, xd, gama, gamad, alpha0, alpha0d&
&   , chords, cl0, cla, vinf, rho, sref, srefd, cl, cd, l, ld, d, dd, &
&   loads, loadsd)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: x(3, n_vort+1)
    REAL, INTENT(IN) :: xd(3, n_vort+1)
    REAL, INTENT(IN) :: gama(n_vort), alpha0(n_vort)
    REAL, INTENT(IN) :: gamad(n_vort), alpha0d(n_vort)
    REAL, INTENT(IN) :: chords(n_vort), cl0(n_vort)
    REAL, INTENT(IN) :: cla(n_vort), vinf(3), rho
! Output variables
    REAL, INTENT(OUT) :: sref, cl, cd, l, d, loads(n_vort)
    REAL, INTENT(OUT) :: srefd, ld, dd, loadsd(n_vort)
! Working variables
    REAL :: uinf(3), aic(3, n_vort, n_vort)
    REAL :: uinfd(3), aicd(3, n_vort, n_vort)
    REAL :: uai(3, n_vort), uni(3, n_vort), si(3, n_vort)
    REAL :: uaid(3, n_vort), unid(3, n_vort), sid(3, n_vort)
    REAL :: areas(n_vort), vlocal(3, n_vort), alphalocal(n_vort)
    REAL :: areasd(n_vort), vlocald(3, n_vort), alphalocald(n_vort)
    REAL :: fcirc(3, n_vort), fbody(3), fbodym, vinfm
    REAL :: fcircd(3, n_vort), fbodyd(3), fbodymd
    INTRINSIC SUM
    INTRINSIC SQRT
    REAL :: temp
    REAL :: temp0
! EXECUTION
! Normalize free-stream velocity
    CALL NORMALIZE(vinf, uinf)
! Get AIC matrix
    CALL GET_AIC_MATRIX_D(n_vort, x, xd, uinf, aic, aicd)
! Get geometric vectors
    CALL GET_GEOM_VECTORS_D(n_vort, x, xd, alpha0, alpha0d, chords, uai&
&                     , uaid, uni, unid, si, sid, areas, areasd)
! Get induced velocities
    unid = 0.0
    uaid = 0.0
    CALL GET_LOCAL_VELS_D(n_vort, gama, gamad, aic, aicd, vinf, uai, &
&                   uaid, uni, unid, vlocal, vlocald, alphalocal, &
&                   alphalocald)
! Get forces on every bound vortex
    CALL COMPUTE_CIRCULATION_FORCES_D(n_vort, rho, vlocal, vlocald, si, &
&                               sid, gama, gamad, fcirc, fcircd)
! Store bending forces
    loadsd = fcircd(3, :)
    loads = fcirc(3, :)
! Get total force in the system of coordinates of the body
    fbodyd = 0.0
    fbodyd(1) = SUM(fcircd(1, :))
    fbody(1) = SUM(fcirc(1, :))
    fbodyd(2) = SUM(fcircd(2, :))
    fbody(2) = SUM(fcirc(2, :))
    fbodyd(3) = SUM(fcircd(3, :))
    fbody(3) = SUM(fcirc(3, :))
! The drag is aligned with the free-stream
    uinfd = 0.0
    CALL DOT_D(fbody, fbodyd, uinf, uinfd, d, dd)
! The rest is the lift force
    CALL NORM_D(fbody, fbodyd, fbodym, fbodymd)
    temp = fbodym*fbodym - d*d
    temp0 = SQRT(temp)
    IF (temp .EQ. 0.0) THEN
      ld = 0.0
    ELSE
      ld = (2*fbodym*fbodymd-2*d*dd)/(2.0*temp0)
    END IF
    l = temp0
! Use the total area as reference
    srefd = SUM(areasd)
    sref = SUM(areas)
! Make results non dimensional
    CALL NORM(vinf, vinfm)
    cl = 2.0*l/sref/vinfm/vinfm/rho
    cd = 2.0*d/sref/vinfm/vinfm/rho
  END SUBROUTINE GET_FUNCTIONS_D

!  Differentiation of get_functions in reverse (adjoint) mode:
!   gradient     of useful results: d loads l sref
!   with respect to varying inputs: alpha0 x gama
!============================================================
  SUBROUTINE GET_FUNCTIONS_B(n_vort, x, xb, gama, gamab, alpha0, alpha0b&
&   , chords, cl0, cla, vinf, rho, sref, srefb, cl, cd, l, lb, d, db, &
&   loads, loadsb)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: x(3, n_vort+1)
    REAL :: xb(3, n_vort+1)
    REAL, INTENT(IN) :: gama(n_vort), alpha0(n_vort)
    REAL :: gamab(n_vort), alpha0b(n_vort)
    REAL, INTENT(IN) :: chords(n_vort), cl0(n_vort)
    REAL, INTENT(IN) :: cla(n_vort), vinf(3), rho
! Output variables
    REAL :: sref, cl, cd, l, d, loads(n_vort)
    REAL :: srefb, lb, db, loadsb(n_vort)
! Working variables
    REAL :: uinf(3), aic(3, n_vort, n_vort)
    REAL :: uinfb(3), aicb(3, n_vort, n_vort)
    REAL :: uai(3, n_vort), uni(3, n_vort), si(3, n_vort)
    REAL :: uaib(3, n_vort), unib(3, n_vort), sib(3, n_vort)
    REAL :: areas(n_vort), vlocal(3, n_vort), alphalocal(n_vort)
    REAL :: areasb(n_vort), vlocalb(3, n_vort), alphalocalb(n_vort)
    REAL :: fcirc(3, n_vort), fbody(3), fbodym, vinfm
    REAL :: fcircb(3, n_vort), fbodyb(3), fbodymb
    INTRINSIC SUM
    INTRINSIC SQRT
    REAL :: tempb
! EXECUTION
! Normalize free-stream velocity
    CALL NORMALIZE(vinf, uinf)
! Get AIC matrix
    CALL GET_AIC_MATRIX(n_vort, x, uinf, aic)
! Get geometric vectors
    CALL PUSHREAL4ARRAY(uai, 3*n_vort)
    CALL GET_GEOM_VECTORS(n_vort, x, alpha0, chords, uai, uni, si, areas&
&                  )
! Get induced velocities
    CALL GET_LOCAL_VELS(n_vort, gama, aic, vinf, uai, uni, vlocal, &
&                 alphalocal)
! Get forces on every bound vortex
    CALL COMPUTE_CIRCULATION_FORCES(n_vort, rho, vlocal, si, gama, fcirc&
&                            )
! Store bending forces
    loads = fcirc(3, :)
! Get total force in the system of coordinates of the body
    fbody(1) = SUM(fcirc(1, :))
    fbody(2) = SUM(fcirc(2, :))
    fbody(3) = SUM(fcirc(3, :))
! The drag is aligned with the free-stream
    CALL DOT(fbody, uinf, d)
! The rest is the lift force
    CALL NORM(fbody, fbodym)
    l = SQRT(fbodym*fbodym - d*d)
! Use the total area as reference
    sref = SUM(areas)
! Make results non dimensional
    CALL NORM(vinf, vinfm)
    cl = 2.0*l/sref/vinfm/vinfm/rho
    cd = 2.0*d/sref/vinfm/vinfm/rho
    areasb = 0.0
    areasb = srefb
    IF (fbodym**2 - d**2 .EQ. 0.0) THEN
      tempb = 0.0
    ELSE
      tempb = lb/(2.0*SQRT(fbodym**2-d**2))
    END IF
    fbodymb = 2*fbodym*tempb
    db = db - 2*d*tempb
    fbodyb = 0.0
    CALL NORM_B(fbody, fbodyb, fbodym, fbodymb)
    uinfb = 0.0
    CALL DOT_B(fbody, fbodyb, uinf, uinfb, d, db)
    fcircb = 0.0
    fcircb(3, :) = fcircb(3, :) + fbodyb(3) + loadsb
    fbodyb(3) = 0.0
    fcircb(2, :) = fcircb(2, :) + fbodyb(2)
    fbodyb(2) = 0.0
    fcircb(1, :) = fcircb(1, :) + fbodyb(1)
    vlocalb = 0.0
    sib = 0.0
    gamab = 0.0
    CALL COMPUTE_CIRCULATION_FORCES_B(n_vort, rho, vlocal, vlocalb, si, &
&                               sib, gama, gamab, fcirc, fcircb)
    alphalocalb = 0.0
    CALL GET_LOCAL_VELS_B(n_vort, gama, gamab, aic, aicb, vinf, uai, &
&                   uaib, uni, unib, vlocal, vlocalb, alphalocal, &
&                   alphalocalb)
    CALL POPREAL4ARRAY(uai, 3*n_vort)
    xb = 0.0
    alpha0b = 0.0
    uaib = 0.0
    unib = 0.0
    CALL GET_GEOM_VECTORS_B(n_vort, x, xb, alpha0, alpha0b, chords, uai&
&                     , uaib, uni, unib, si, sib, areas, areasb)
    CALL GET_AIC_MATRIX_B(n_vort, x, xb, uinf, aic, aicb)
  END SUBROUTINE GET_FUNCTIONS_B

!============================================================
  SUBROUTINE GET_FUNCTIONS(n_vort, x, gama, alpha0, chords, cl0, cla, &
&   vinf, rho, sref, cl, cd, l, d, loads)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: x(3, n_vort+1)
    REAL, INTENT(IN) :: gama(n_vort), alpha0(n_vort)
    REAL, INTENT(IN) :: chords(n_vort), cl0(n_vort)
    REAL, INTENT(IN) :: cla(n_vort), vinf(3), rho
! Output variables
    REAL, INTENT(OUT) :: sref, cl, cd, l, d, loads(n_vort)
! Working variables
    REAL :: uinf(3), aic(3, n_vort, n_vort)
    REAL :: uai(3, n_vort), uni(3, n_vort), si(3, n_vort)
    REAL :: areas(n_vort), vlocal(3, n_vort), alphalocal(n_vort)
    REAL :: fcirc(3, n_vort), fbody(3), fbodym, vinfm
    INTRINSIC SUM
    INTRINSIC SQRT
! EXECUTION
! Normalize free-stream velocity
    CALL NORMALIZE(vinf, uinf)
! Get AIC matrix
    CALL GET_AIC_MATRIX(n_vort, x, uinf, aic)
! Get geometric vectors
    CALL GET_GEOM_VECTORS(n_vort, x, alpha0, chords, uai, uni, si, areas&
&                  )
! Get induced velocities
    CALL GET_LOCAL_VELS(n_vort, gama, aic, vinf, uai, uni, vlocal, &
&                 alphalocal)
! Get forces on every bound vortex
    CALL COMPUTE_CIRCULATION_FORCES(n_vort, rho, vlocal, si, gama, fcirc&
&                            )
! Store bending forces
    loads = fcirc(3, :)
! Get total force in the system of coordinates of the body
    fbody(1) = SUM(fcirc(1, :))
    fbody(2) = SUM(fcirc(2, :))
    fbody(3) = SUM(fcirc(3, :))
! The drag is aligned with the free-stream
    CALL DOT(fbody, uinf, d)
! The rest is the lift force
    CALL NORM(fbody, fbodym)
    l = SQRT(fbodym*fbodym - d*d)
! Use the total area as reference
    sref = SUM(areas)
! Make results non dimensional
    CALL NORM(vinf, vinfm)
    cl = 2.0*l/sref/vinfm/vinfm/rho
    cd = 2.0*d/sref/vinfm/vinfm/rho
  END SUBROUTINE GET_FUNCTIONS

!  Differentiation of norm in forward (tangent) mode:
!   variations   of useful results: am
!   with respect to varying inputs: a
!============================================================
  SUBROUTINE NORM_D(a, ad, am, amd)
    IMPLICIT NONE
    REAL, INTENT(IN) :: a(3)
    REAL, INTENT(IN) :: ad(3)
    REAL, INTENT(OUT) :: am
    REAL, INTENT(OUT) :: amd
    INTRINSIC SQRT
    REAL :: temp
    REAL :: temp0
    temp = a(1)*a(1) + a(2)*a(2) + a(3)*a(3)
    temp0 = SQRT(temp)
    IF (temp .EQ. 0.0) THEN
      amd = 0.0
    ELSE
      amd = (2*a(1)*ad(1)+2*a(2)*ad(2)+2*a(3)*ad(3))/(2.0*temp0)
    END IF
    am = temp0
  END SUBROUTINE NORM_D

!  Differentiation of norm in reverse (adjoint) mode:
!   gradient     of useful results: am a
!   with respect to varying inputs: a
!============================================================
  SUBROUTINE NORM_B(a, ab, am, amb)
    IMPLICIT NONE
    REAL, INTENT(IN) :: a(3)
    REAL :: ab(3)
    REAL :: am
    REAL :: amb
    INTRINSIC SQRT
    REAL :: tempb
    CALL PUSHREAL4(am)
    am = SQRT(a(1)*a(1) + a(2)*a(2) + a(3)*a(3))
    CALL POPREAL4(am)
    IF (a(1)**2 + a(2)**2 + a(3)**2 .EQ. 0.0) THEN
      tempb = 0.0
    ELSE
      tempb = amb/(2.0*SQRT(a(1)**2+a(2)**2+a(3)**2))
    END IF
    ab(1) = ab(1) + 2*a(1)*tempb
    ab(2) = ab(2) + 2*a(2)*tempb
    ab(3) = ab(3) + 2*a(3)*tempb
  END SUBROUTINE NORM_B

!============================================================
  SUBROUTINE NORM(a, am)
    IMPLICIT NONE
    REAL, INTENT(IN) :: a(3)
    REAL, INTENT(OUT) :: am
    INTRINSIC SQRT
    am = SQRT(a(1)*a(1) + a(2)*a(2) + a(3)*a(3))
  END SUBROUTINE NORM

!  Differentiation of normalize in forward (tangent) mode:
!   variations   of useful results: an
!   with respect to varying inputs: a
!============================================================
  SUBROUTINE NORMALIZE_D(a, ad, an, and)
    IMPLICIT NONE
    REAL, INTENT(IN) :: a(3)
    REAL, INTENT(IN) :: ad(3)
    REAL, INTENT(OUT) :: an(3)
    REAL, INTENT(OUT) :: and(3)
    REAL :: am
    REAL :: amd
    CALL NORM_D(a, ad, am, amd)
    and = (ad-a*amd/am)/am
    an = a/am
  END SUBROUTINE NORMALIZE_D

!  Differentiation of normalize in reverse (adjoint) mode:
!   gradient     of useful results: an a
!   with respect to varying inputs: a
!============================================================
  SUBROUTINE NORMALIZE_B(a, ab, an, anb)
    IMPLICIT NONE
    REAL, INTENT(IN) :: a(3)
    REAL :: ab(3)
    REAL :: an(3)
    REAL :: anb(3)
    REAL :: am
    REAL :: amb
    CALL NORM(a, am)
    CALL PUSHREAL4ARRAY(an, 3)
    an = a/am
    CALL POPREAL4ARRAY(an, 3)
    ab = ab + anb/am
    amb = -(SUM(a*anb)/am**2)
    CALL NORM_B(a, ab, am, amb)
  END SUBROUTINE NORMALIZE_B

!============================================================
  SUBROUTINE NORMALIZE(a, an)
    IMPLICIT NONE
    REAL, INTENT(IN) :: a(3)
    REAL, INTENT(OUT) :: an(3)
    REAL :: am
    CALL NORM(a, am)
    an = a/am
  END SUBROUTINE NORMALIZE

!  Differentiation of dot in forward (tangent) mode:
!   variations   of useful results: adb
!   with respect to varying inputs: a b
!============================================================
  SUBROUTINE DOT_D(a, ad, b, bd, adb, adbd)
    IMPLICIT NONE
    REAL, INTENT(IN) :: a(3), b(3)
    REAL, INTENT(IN) :: ad(3), bd(3)
    REAL, INTENT(OUT) :: adb
    REAL, INTENT(OUT) :: adbd
    INTRINSIC SUM
    adbd = SUM(b*ad + a*bd)
    adb = SUM(a*b)
  END SUBROUTINE DOT_D

!  Differentiation of dot in reverse (adjoint) mode:
!   gradient     of useful results: adb a b
!   with respect to varying inputs: a b
!============================================================
  SUBROUTINE DOT_B(a, ab, b, bb, adb, adbb)
    IMPLICIT NONE
    REAL, INTENT(IN) :: a(3), b(3)
    REAL :: ab(3), bb(3)
    REAL :: adb
    REAL :: adbb
    INTRINSIC SUM
    CALL PUSHREAL4(adb)
    adb = SUM(a*b)
    CALL POPREAL4(adb)
    ab = ab + b*adbb
    bb = bb + a*adbb
  END SUBROUTINE DOT_B

!============================================================
  SUBROUTINE DOT(a, b, adb)
    IMPLICIT NONE
    REAL, INTENT(IN) :: a(3), b(3)
    REAL, INTENT(OUT) :: adb
    INTRINSIC SUM
    adb = SUM(a*b)
  END SUBROUTINE DOT

!  Differentiation of cross in forward (tangent) mode:
!   variations   of useful results: acb
!   with respect to varying inputs: acb a b
!============================================================
  SUBROUTINE CROSS_D(a, ad, b, bd, acb, acbd)
    IMPLICIT NONE
    REAL, INTENT(IN) :: a(3), b(3)
    REAL, INTENT(IN) :: ad(3), bd(3)
    REAL, INTENT(OUT) :: acb(3)
    REAL, INTENT(OUT) :: acbd(3)
    acbd(1) = b(3)*ad(2) + a(2)*bd(3) - b(2)*ad(3) - a(3)*bd(2)
    acb(1) = a(2)*b(3) - a(3)*b(2)
    acbd(2) = b(1)*ad(3) + a(3)*bd(1) - b(3)*ad(1) - a(1)*bd(3)
    acb(2) = a(3)*b(1) - a(1)*b(3)
    acbd(3) = b(2)*ad(1) + a(1)*bd(2) - b(1)*ad(2) - a(2)*bd(1)
    acb(3) = a(1)*b(2) - a(2)*b(1)
  END SUBROUTINE CROSS_D

!  Differentiation of cross in reverse (adjoint) mode:
!   gradient     of useful results: acb a b
!   with respect to varying inputs: acb a b
!============================================================
  SUBROUTINE CROSS_B(a, ab, b, bb, acb, acbb)
    IMPLICIT NONE
    REAL, INTENT(IN) :: a(3), b(3)
    REAL :: ab(3), bb(3)
    REAL :: acb(3)
    REAL :: acbb(3)
    CALL PUSHREAL4(acb(1))
    acb(1) = a(2)*b(3) - a(3)*b(2)
    CALL PUSHREAL4(acb(2))
    acb(2) = a(3)*b(1) - a(1)*b(3)
    CALL PUSHREAL4(acb(3))
    acb(3) = a(1)*b(2) - a(2)*b(1)
    CALL POPREAL4(acb(3))
    ab(1) = ab(1) + b(2)*acbb(3) - b(3)*acbb(2)
    bb(2) = bb(2) + a(1)*acbb(3) - a(3)*acbb(1)
    ab(2) = ab(2) + b(3)*acbb(1) - b(1)*acbb(3)
    bb(1) = bb(1) + a(3)*acbb(2) - a(2)*acbb(3)
    acbb(3) = 0.0
    CALL POPREAL4(acb(2))
    ab(3) = ab(3) + b(1)*acbb(2) - b(2)*acbb(1)
    bb(3) = bb(3) + a(2)*acbb(1) - a(1)*acbb(2)
    acbb(2) = 0.0
    CALL POPREAL4(acb(1))
    acbb(1) = 0.0
  END SUBROUTINE CROSS_B

!============================================================
  SUBROUTINE CROSS(a, b, acb)
    IMPLICIT NONE
    REAL, INTENT(IN) :: a(3), b(3)
    REAL, INTENT(OUT) :: acb(3)
    acb(1) = a(2)*b(3) - a(3)*b(2)
    acb(2) = a(3)*b(1) - a(1)*b(3)
    acb(3) = a(1)*b(2) - a(2)*b(1)
  END SUBROUTINE CROSS

!  Differentiation of tapenade_main in forward (tangent) mode:
!   variations   of useful results: d res loads l sref
!   with respect to varying inputs: res alpha0 x gama
!============================================================
  SUBROUTINE TAPENADE_MAIN_D(n_vort, x, xd, gama, gamad, alpha0, alpha0d&
&   , chords, cl0, cla, vinf, rho, res, resd, sref, srefd, cl, cd, l, ld&
&   , d, dd, loads, loadsd)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: x(3, n_vort+1)
    REAL, INTENT(IN) :: xd(3, n_vort+1)
    REAL, INTENT(IN) :: gama(n_vort), alpha0(n_vort)
    REAL, INTENT(IN) :: gamad(n_vort), alpha0d(n_vort)
    REAL, INTENT(IN) :: chords(n_vort), cl0(n_vort)
    REAL, INTENT(IN) :: cla(n_vort), vinf(3), rho
! Output variables
    REAL, INTENT(OUT) :: res(n_vort), sref, cl, cd, l, d
    REAL, INTENT(OUT) :: resd(n_vort), srefd, ld, dd
    REAL, INTENT(OUT) :: loads(n_vort)
    REAL, INTENT(OUT) :: loadsd(n_vort)
! EXECUTION
! Call relevant subroutines
    CALL GET_RESIDUALS_D(n_vort, x, xd, gama, gamad, alpha0, alpha0d, &
&                  chords, cl0, cla, vinf, rho, res, resd)
    CALL GET_FUNCTIONS_D(n_vort, x, xd, gama, gamad, alpha0, alpha0d, &
&                  chords, cl0, cla, vinf, rho, sref, srefd, cl, cd, l, &
&                  ld, d, dd, loads, loadsd)
  END SUBROUTINE TAPENADE_MAIN_D

!  Differentiation of tapenade_main in reverse (adjoint) mode:
!   gradient     of useful results: d res loads l sref
!   with respect to varying inputs: res alpha0 x gama
!============================================================
  SUBROUTINE TAPENADE_MAIN_B(n_vort, x, xb, gama, gamab, alpha0, alpha0b&
&   , chords, cl0, cla, vinf, rho, res, resb, sref, srefb, cl, cd, l, lb&
&   , d, db, loads, loadsb)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: x(3, n_vort+1)
    REAL :: xb(3, n_vort+1)
    REAL, INTENT(IN) :: gama(n_vort), alpha0(n_vort)
    REAL :: gamab(n_vort), alpha0b(n_vort)
    REAL, INTENT(IN) :: chords(n_vort), cl0(n_vort)
    REAL, INTENT(IN) :: cla(n_vort), vinf(3), rho
! Output variables
    REAL :: res(n_vort), sref, cl, cd, l, d
    REAL :: resb(n_vort), srefb, lb, db
    REAL :: loads(n_vort)
    REAL :: loadsb(n_vort)
! EXECUTION
! Call relevant subroutines
    CALL GET_RESIDUALS(n_vort, x, gama, alpha0, chords, cl0, cla, vinf, &
&                rho, res)
    CALL GET_FUNCTIONS(n_vort, x, gama, alpha0, chords, cl0, cla, vinf, &
&                rho, sref, cl, cd, l, d, loads)
    CALL GET_FUNCTIONS_B(n_vort, x, xb, gama, gamab, alpha0, alpha0b, &
&                  chords, cl0, cla, vinf, rho, sref, srefb, cl, cd, l, &
&                  lb, d, db, loads, loadsb)
    CALL GET_RESIDUALS_B(n_vort, x, xb, gama, gamab, alpha0, alpha0b, &
&                  chords, cl0, cla, vinf, rho, res, resb)
  END SUBROUTINE TAPENADE_MAIN_B

!============================================================
  SUBROUTINE TAPENADE_MAIN(n_vort, x, gama, alpha0, chords, cl0, cla, &
&   vinf, rho, res, sref, cl, cd, l, d, loads)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_vort
    REAL, INTENT(IN) :: x(3, n_vort+1)
    REAL, INTENT(IN) :: gama(n_vort), alpha0(n_vort)
    REAL, INTENT(IN) :: chords(n_vort), cl0(n_vort)
    REAL, INTENT(IN) :: cla(n_vort), vinf(3), rho
! Output variables
    REAL, INTENT(OUT) :: res(n_vort), sref, cl, cd, l, d
    REAL, INTENT(OUT) :: loads(n_vort)
! EXECUTION
! Call relevant subroutines
    CALL GET_RESIDUALS(n_vort, x, gama, alpha0, chords, cl0, cla, vinf, &
&                rho, res)
    CALL GET_FUNCTIONS(n_vort, x, gama, alpha0, chords, cl0, cla, vinf, &
&                rho, sref, cl, cd, l, d, loads)
  END SUBROUTINE TAPENADE_MAIN

END MODULE LLT_MODULE_DIFF


!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.15 (master) - 15 Apr 2020 11:54
!
MODULE ASA_MODULE_DIFF
  IMPLICIT NONE
  REAL, PARAMETER :: zero=0.0
  REAL, PARAMETER :: pi=3.1415926535897932384626
  REAL, PARAMETER :: eps=EPSILON(zero)

CONTAINS
!  Differentiation of transfer_disps in forward (tangent) mode:
!   variations   of useful results: xllt
!   with respect to varying inputs: d
  SUBROUTINE TRANSFER_DISPS_D(n_nodes, xfem, d, dd, xllt, xlltd)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_nodes
    REAL, INTENT(IN) :: xfem(3, n_nodes), d(2*n_nodes)
    REAL, INTENT(IN) :: dd(2*n_nodes)
! Output variables
    REAL, INTENT(OUT) :: xllt(3, n_nodes)
    REAL, INTENT(OUT) :: xlltd(3, n_nodes)
! EXECUTION
! Copy Xfem to Xllt, but just apply displacements in the z direction
    xllt(1, :) = xfem(1, :)
    xllt(2, :) = xfem(2, :)
    xlltd = 0.0
    xlltd(3, :) = dd(::2)
    xllt(3, :) = xfem(3, :) + d(::2)
  END SUBROUTINE TRANSFER_DISPS_D

!  Differentiation of transfer_disps in reverse (adjoint) mode:
!   gradient     of useful results: d xllt
!   with respect to varying inputs: d
  SUBROUTINE TRANSFER_DISPS_B(n_nodes, xfem, d, db, xllt, xlltb)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_nodes
    REAL, INTENT(IN) :: xfem(3, n_nodes), d(2*n_nodes)
    REAL :: db(2*n_nodes)
! Output variables
    REAL :: xllt(3, n_nodes)
    REAL :: xlltb(3, n_nodes)
! EXECUTION
! Copy Xfem to Xllt, but just apply displacements in the z direction
    xllt(1, :) = xfem(1, :)
    xllt(2, :) = xfem(2, :)
    xllt(3, :) = xfem(3, :) + d(::2)
    db(1:2*n_nodes:2) = db(1:2*n_nodes:2) + xlltb(3, :)
  END SUBROUTINE TRANSFER_DISPS_B

  SUBROUTINE TRANSFER_DISPS(n_nodes, xfem, d, xllt)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_nodes
    REAL, INTENT(IN) :: xfem(3, n_nodes), d(2*n_nodes)
! Output variables
    REAL, INTENT(OUT) :: xllt(3, n_nodes)
! EXECUTION
! Copy Xfem to Xllt, but just apply displacements in the z direction
    xllt(1, :) = xfem(1, :)
    xllt(2, :) = xfem(2, :)
    xllt(3, :) = xfem(3, :) + d(::2)
  END SUBROUTINE TRANSFER_DISPS

!  Differentiation of transfer_forces in forward (tangent) mode:
!   variations   of useful results: f
!   with respect to varying inputs: loads
!============================================================
  SUBROUTINE TRANSFER_FORCES_D(n_nodes, xfem, loads, loadsd, f, fd)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_nodes
    REAL, INTENT(IN) :: xfem(3, n_nodes), loads(n_nodes-1)
    REAL, INTENT(IN) :: loadsd(n_nodes-1)
! Output variables
    REAL, INTENT(OUT) :: f(2*n_nodes)
    REAL, INTENT(OUT) :: fd(2*n_nodes)
! Working variables
    REAL :: l(n_nodes-1)
    INTEGER :: ii
! EXECUTION
! Compute the panel lengths along the span axis (y-dim)
    l = xfem(2, 2:n_nodes) - xfem(2, 1:n_nodes-1)
! Initialize consistent force vector
    f = zero
    fd = 0.0
! Compute contributions of each horseshoe vortex to the consistent forces
    DO ii=1,n_nodes-1
      fd(2*ii-1) = fd(2*ii-1) + loadsd(ii)/2
      f(2*ii-1) = f(2*ii-1) + loads(ii)/2
      fd(2*ii) = fd(2*ii) + l(ii)*loadsd(ii)/12
      f(2*ii) = f(2*ii) + loads(ii)*l(ii)/12
      fd(2*ii+1) = fd(2*ii+1) + loadsd(ii)/2
      f(2*ii+1) = f(2*ii+1) + loads(ii)/2
      fd(2*ii+2) = fd(2*ii+2) - l(ii)*loadsd(ii)/12
      f(2*ii+2) = f(2*ii+2) - loads(ii)*l(ii)/12
    END DO
  END SUBROUTINE TRANSFER_FORCES_D

!  Differentiation of transfer_forces in reverse (adjoint) mode:
!   gradient     of useful results: f
!   with respect to varying inputs: loads
!============================================================
  SUBROUTINE TRANSFER_FORCES_B(n_nodes, xfem, loads, loadsb, f, fb)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_nodes
    REAL, INTENT(IN) :: xfem(3, n_nodes), loads(n_nodes-1)
    REAL :: loadsb(n_nodes-1)
! Output variables
    REAL :: f(2*n_nodes)
    REAL :: fb(2*n_nodes)
! Working variables
    REAL :: l(n_nodes-1)
    INTEGER :: ii
! EXECUTION
! Compute the panel lengths along the span axis (y-dim)
    l = xfem(2, 2:n_nodes) - xfem(2, 1:n_nodes-1)
! Initialize consistent force vector
    f = zero
! Compute contributions of each horseshoe vortex to the consistent forces
    DO ii=1,n_nodes-1
      f(2*ii-1) = f(2*ii-1) + loads(ii)/2
      f(2*ii) = f(2*ii) + loads(ii)*l(ii)/12
      f(2*ii+1) = f(2*ii+1) + loads(ii)/2
      f(2*ii+2) = f(2*ii+2) - loads(ii)*l(ii)/12
    END DO
    loadsb = 0.0
    DO ii=n_nodes-1,1,-1
      loadsb(ii) = loadsb(ii) + fb(2*ii+1)/2 - l(ii)*fb(2*ii+2)/12 + l(&
&       ii)*fb(2*ii)/12 + fb(2*ii-1)/2
    END DO
  END SUBROUTINE TRANSFER_FORCES_B

!============================================================
  SUBROUTINE TRANSFER_FORCES(n_nodes, xfem, loads, f)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_nodes
    REAL, INTENT(IN) :: xfem(3, n_nodes), loads(n_nodes-1)
! Output variables
    REAL, INTENT(OUT) :: f(2*n_nodes)
! Working variables
    REAL :: l(n_nodes-1)
    INTEGER :: ii
! EXECUTION
! Compute the panel lengths along the span axis (y-dim)
    l = xfem(2, 2:n_nodes) - xfem(2, 1:n_nodes-1)
! Initialize consistent force vector
    f = zero
! Compute contributions of each horseshoe vortex to the consistent forces
    DO ii=1,n_nodes-1
      f(2*ii-1) = f(2*ii-1) + loads(ii)/2
      f(2*ii) = f(2*ii) + loads(ii)*l(ii)/12
      f(2*ii+1) = f(2*ii+1) + loads(ii)/2
      f(2*ii+2) = f(2*ii+2) - loads(ii)*l(ii)/12
    END DO
  END SUBROUTINE TRANSFER_FORCES

!  Differentiation of asa_analysis in forward (tangent) mode:
!   variations   of useful results: liftexcess ksmargin resllt
!                fb margins resfem weight
!   with respect to varying inputs: d alpha0 t resllt margins gama
!   RW status of diff variables: liftexcess:out d:in alpha0:in
!                t:in ksmargin:out resllt:in-out fb:out margins:in-out
!                resfem:out gama:in weight:out
!============================================================
  SUBROUTINE ASA_ANALYSIS_D(n_panels, n_cons, gama, gamad, alpha0, &
&   alpha0d, chords, xfem, r, t, td, d, dd, cl0, cla, vinf, rhoair, e, &
&   rhomat, sigmay, pks, conids, cd0, fixedmass, g, endurance, tsfc, &
&   loadfactor, resllt, reslltd, resfem, resfemd, liftexcess, &
&   liftexcessd, margins, marginsd, ksmargin, ksmargind, fb, fbd, weight&
&   , weightd, sref, cl)
! This subroutine computes the residuals of the coupled aerostructural
! problem.
!
! INPUTS
!
! n_panels: integer -> Number of horseshoe panels and beams (the same).
! n_cons: integer -> Number of constrained DOFs.
! Gama: real(n_panels) -> Circulation intensity of each horseshoe vortex.
! alpha0: real(n_panels) -> Array of local incidence angles.
! chords: real(n_panels) -> Array of local chords.
! Xfem: real(3,n_panels+1) -> Coordinates of the undeformed beam nodes.
! r: real(n_panels) -> Radius of each beam element.
! t: real(n_panels) -> Wall thickness of each beam element.
! d: real(2*(n_panels+1)) -> Displacements values of all DOFs (including
!                           the constrained ones).
! cl0: real(n_panels) -> cl0 of each 2D section
! cla: real(n_panels) -> lift curve slope of each 2D section [1/rad]
! Vinf: real(3) -> Free-stream velocity vector
! rhoAir: real -> Air density
! E: real -> Young's module of the beam material.
! rhoMat: real -> Density of the beam material.
! sigmaY: real -> Yield stress of the beam material.
! pKS: real -> Constant of the KS functons used to aggregate stresses.
! conIDs: integer(n_cons) -> Indices of the DOFs of the Kf matrix that
!                            should be constrained.
! CD0: real -> Parasite drag that will be added to the induced drag.
! fixedMass: real -> Fixed mass of the aircraft less the wing structure.
! g: real -> Acceleration of gravity.
! Endurance: real -> Desired endurance of the aircraft.
! TSFC: real -> Thrust specific fuel consumption of the engine.
! loadFactor: real -> Factor applied to the structural failure margin
!                     to consider a multiplicative factor in the loads.
!
! OUTPUTS
!
! resllt: real(n_panels) -> Residuals of the LLT method
! resfem: real(2*(n_panels+1)) -> Residuals of the FEM model
!                                 considering all DOFs (including the
!                                 constrained ones). The residuals
!                                 of the constrained DOFs are the
!                                 displacements themselves, so that the
!                                 solver drives them to zero. We
!                                 modify the K matrix in appy_cons to
!                                 achieve that.
! liftExcess: real -> Difference between the generated lift and the.
!                     aircraft weight. This value is normalized:
!                     liftExcess = Lift/Weigth - 1
! margins: real(2*n_panels) -> Margin from Von Mises stress at each node
!                              with respect to the yield stress.
!                              The margins are computed as:
!                              margin = 1.0 - sigma_vm/sigmaY
!                              Negative margins indicate failure.
!                              Internal nodes have two values
!                              corresponding to the beam sections on
!                              either side. KSmargin is the aggregation of
!                              these values.
! KSmargin: real -> Aggregated safety margin. This value
!                   is a conservative estimate of the minimum
!                   margin value in the structure. This estimate
!                   gets closer to the real value as we increase
!                   pKS, but this may lead to numerical issues.
! FB: real -> Fuel burn (in Force units).
! Weight: real -> Total weight of the aircraft (in Force units)
!                 (fixed weight + structure weight + fuel weight)
! Sref: real -> Area of all panels
! CL: real -> Lift coefficient (adimensionalized by Sref)
    USE LLT_MODULE_DIFF, ONLY : tapenade_main, tapenade_main_d
    USE FEM_MODULE_DIFF, ONLY : fem_main, fem_main_d
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_panels, n_cons
    REAL, INTENT(IN) :: gama(n_panels), alpha0(n_panels)
    REAL, INTENT(IN) :: gamad(n_panels), alpha0d(n_panels)
    REAL, INTENT(IN) :: chords(n_panels)
    REAL, INTENT(IN) :: xfem(3, n_panels+1)
    REAL, INTENT(IN) :: r(n_panels), t(n_panels)
    REAL, INTENT(IN) :: td(n_panels)
    REAL, INTENT(IN) :: d(2*(n_panels+1))
    REAL, INTENT(IN) :: dd(2*(n_panels+1))
    REAL, INTENT(IN) :: cl0(n_panels), cla(n_panels), vinf(3), rhoair
    REAL, INTENT(IN) :: e, rhomat, sigmay, pks
    INTEGER, INTENT(IN) :: conids(n_cons)
    REAL, INTENT(IN) :: cd0, fixedmass, g, endurance, tsfc, loadfactor
! Output variables
    REAL, INTENT(OUT) :: resllt(n_panels), resfem(2*(n_panels+1))
    REAL, INTENT(OUT) :: reslltd(n_panels), resfemd(2*(n_panels+1))
    REAL, INTENT(OUT) :: liftexcess, margins(2*n_panels)
    REAL, INTENT(OUT) :: liftexcessd, marginsd(2*n_panels)
    REAL, INTENT(OUT) :: ksmargin, fb, weight, sref, cl
    REAL, INTENT(OUT) :: ksmargind, fbd, weightd
! Working variables
    REAL :: xllt(3, n_panels+1)
    REAL :: xlltd(3, n_panels+1)
    REAL :: loads(n_panels), f(2*(n_panels+1))
    REAL :: loadsd(n_panels), fd(2*(n_panels+1))
    REAL :: cd, l, di, structuremass, drag, aux
    REAL :: ld, did, structuremassd, dragd, auxd
    INTRINSIC SUM
    INTRINSIC EXP
    INTEGER :: arg1
    REAL :: temp
    REAL :: srefd
! EXECUTION
    arg1 = n_panels + 1
    CALL TRANSFER_DISPS_D(arg1, xfem, d, dd, xllt, xlltd)
    CALL TAPENADE_MAIN_D(n_panels, xllt, xlltd, gama, gamad, alpha0, &
&                  alpha0d, chords, cl0, cla, vinf, rhoair, resllt, &
&                  reslltd, sref, srefd, cl, cd, l, ld, di, did, loads, &
&                  loadsd)
    arg1 = n_panels + 1
    CALL TRANSFER_FORCES_D(arg1, xfem, loads, loadsd, f, fd)
    CALL FEM_MAIN_D(n_panels, n_cons, xfem, r, t, td, f, fd, d, dd, e, &
&             rhomat, sigmay, pks, conids, resfem, resfemd, &
&             structuremass, structuremassd, margins, marginsd, ksmargin&
&             , ksmargind)
    marginsd = loadfactor*marginsd
    margins = loadfactor*margins + 1 - loadfactor
    ksmargind = loadfactor*ksmargind
    ksmargin = ksmargin*loadfactor + 1 - loadfactor
    temp = SUM(vinf*vinf)
    dragd = did + temp*rhoair*cd0*srefd/2
    drag = di + temp*(rhoair*cd0*(sref/2))
    temp = endurance*tsfc*drag/l
    auxd = EXP(temp)*endurance*tsfc*(dragd-drag*ld/l)/l
    aux = EXP(temp)
    fbd = g*((aux-1)*structuremassd+(fixedmass+structuremass)*auxd)
    fb = g*(fixedmass+structuremass)*(aux-1)
    weightd = g*structuremassd + fbd
    weight = g*(fixedmass+structuremass) + fb
    liftexcessd = (ld-l*weightd/weight)/weight
    liftexcess = l/weight - 1
  END SUBROUTINE ASA_ANALYSIS_D

!  Differentiation of asa_analysis in reverse (adjoint) mode:
!   gradient     of useful results: liftexcess ksmargin resllt
!                fb margins resfem weight
!   with respect to varying inputs: liftexcess d alpha0 t ksmargin
!                resllt fb margins resfem gama weight
!   RW status of diff variables: liftexcess:in-zero d:out alpha0:out
!                t:out ksmargin:in-zero resllt:in-out fb:in-zero
!                margins:in-out resfem:in-zero gama:out weight:in-zero
!============================================================
  SUBROUTINE ASA_ANALYSIS_B(n_panels, n_cons, gama, gamab, alpha0, &
&   alpha0b, chords, xfem, r, t, tb, d, db, cl0, cla, vinf, rhoair, e, &
&   rhomat, sigmay, pks, conids, cd0, fixedmass, g, endurance, tsfc, &
&   loadfactor, resllt, reslltb, resfem, resfemb, liftexcess, &
&   liftexcessb, margins, marginsb, ksmargin, ksmarginb, fb, fbb, weight&
&   , weightb, sref, cl)
! This subroutine computes the residuals of the coupled aerostructural
! problem.
!
! INPUTS
!
! n_panels: integer -> Number of horseshoe panels and beams (the same).
! n_cons: integer -> Number of constrained DOFs.
! Gama: real(n_panels) -> Circulation intensity of each horseshoe vortex.
! alpha0: real(n_panels) -> Array of local incidence angles.
! chords: real(n_panels) -> Array of local chords.
! Xfem: real(3,n_panels+1) -> Coordinates of the undeformed beam nodes.
! r: real(n_panels) -> Radius of each beam element.
! t: real(n_panels) -> Wall thickness of each beam element.
! d: real(2*(n_panels+1)) -> Displacements values of all DOFs (including
!                           the constrained ones).
! cl0: real(n_panels) -> cl0 of each 2D section
! cla: real(n_panels) -> lift curve slope of each 2D section [1/rad]
! Vinf: real(3) -> Free-stream velocity vector
! rhoAir: real -> Air density
! E: real -> Young's module of the beam material.
! rhoMat: real -> Density of the beam material.
! sigmaY: real -> Yield stress of the beam material.
! pKS: real -> Constant of the KS functons used to aggregate stresses.
! conIDs: integer(n_cons) -> Indices of the DOFs of the Kf matrix that
!                            should be constrained.
! CD0: real -> Parasite drag that will be added to the induced drag.
! fixedMass: real -> Fixed mass of the aircraft less the wing structure.
! g: real -> Acceleration of gravity.
! Endurance: real -> Desired endurance of the aircraft.
! TSFC: real -> Thrust specific fuel consumption of the engine.
! loadFactor: real -> Factor applied to the structural failure margin
!                     to consider a multiplicative factor in the loads.
!
! OUTPUTS
!
! resllt: real(n_panels) -> Residuals of the LLT method
! resfem: real(2*(n_panels+1)) -> Residuals of the FEM model
!                                 considering all DOFs (including the
!                                 constrained ones). The residuals
!                                 of the constrained DOFs are the
!                                 displacements themselves, so that the
!                                 solver drives them to zero. We
!                                 modify the K matrix in appy_cons to
!                                 achieve that.
! liftExcess: real -> Difference between the generated lift and the.
!                     aircraft weight. This value is normalized:
!                     liftExcess = Lift/Weigth - 1
! margins: real(2*n_panels) -> Margin from Von Mises stress at each node
!                              with respect to the yield stress.
!                              The margins are computed as:
!                              margin = 1.0 - sigma_vm/sigmaY
!                              Negative margins indicate failure.
!                              Internal nodes have two values
!                              corresponding to the beam sections on
!                              either side. KSmargin is the aggregation of
!                              these values.
! KSmargin: real -> Aggregated safety margin. This value
!                   is a conservative estimate of the minimum
!                   margin value in the structure. This estimate
!                   gets closer to the real value as we increase
!                   pKS, but this may lead to numerical issues.
! FB: real -> Fuel burn (in Force units).
! Weight: real -> Total weight of the aircraft (in Force units)
!                 (fixed weight + structure weight + fuel weight)
! Sref: real -> Area of all panels
! CL: real -> Lift coefficient (adimensionalized by Sref)
    USE LLT_MODULE_DIFF, ONLY : tapenade_main, tapenade_main_b
    USE FEM_MODULE_DIFF, ONLY : fem_main, fem_main_b
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_panels, n_cons
    REAL, INTENT(IN) :: gama(n_panels), alpha0(n_panels)
    REAL :: gamab(n_panels), alpha0b(n_panels)
    REAL, INTENT(IN) :: chords(n_panels)
    REAL, INTENT(IN) :: xfem(3, n_panels+1)
    REAL, INTENT(IN) :: r(n_panels), t(n_panels)
    REAL :: tb(n_panels)
    REAL, INTENT(IN) :: d(2*(n_panels+1))
    REAL :: db(2*(n_panels+1))
    REAL, INTENT(IN) :: cl0(n_panels), cla(n_panels), vinf(3), rhoair
    REAL, INTENT(IN) :: e, rhomat, sigmay, pks
    INTEGER, INTENT(IN) :: conids(n_cons)
    REAL, INTENT(IN) :: cd0, fixedmass, g, endurance, tsfc, loadfactor
! Output variables
    REAL :: resllt(n_panels), resfem(2*(n_panels+1))
    REAL :: reslltb(n_panels), resfemb(2*(n_panels+1))
    REAL :: liftexcess, margins(2*n_panels)
    REAL :: liftexcessb, marginsb(2*n_panels)
    REAL :: ksmargin, fb, weight, sref, cl
    REAL :: ksmarginb, fbb, weightb, srefb
! Working variables
    REAL :: xllt(3, n_panels+1)
    REAL :: xlltb(3, n_panels+1)
    REAL :: loads(n_panels), f(2*(n_panels+1))
    REAL :: loadsb(n_panels), fb0(2*(n_panels+1))
    REAL :: cd, l, di, structuremass, drag, aux
    REAL :: lb, dib, structuremassb, dragb, auxb
    INTRINSIC SUM
    INTRINSIC EXP
    INTEGER :: arg1
    REAL :: tempb
! EXECUTION
    arg1 = n_panels + 1
    CALL TRANSFER_DISPS(arg1, xfem, d, xllt)
    CALL TAPENADE_MAIN(n_panels, xllt, gama, alpha0, chords, cl0, cla, &
&                vinf, rhoair, resllt, sref, cl, cd, l, di, loads)
    CALL PUSHINTEGER4(arg1)
    arg1 = n_panels + 1
    CALL TRANSFER_FORCES(arg1, xfem, loads, f)
    CALL PUSHREAL4ARRAY(margins, 2*n_panels)
    CALL FEM_MAIN(n_panels, n_cons, xfem, r, t, f, d, e, rhomat, sigmay&
&           , pks, conids, resfem, structuremass, margins, ksmargin)
    margins = loadfactor*margins + 1 - loadfactor
    ksmargin = ksmargin*loadfactor + 1 - loadfactor
    drag = di + rhoair*SUM(vinf*vinf)/2*sref*cd0
    aux = EXP(endurance*tsfc*drag/l)
    fb = g*(fixedmass+structuremass)*(aux-1)
    weight = g*(fixedmass+structuremass) + fb
    liftexcess = l/weight - 1
    weightb = weightb - l*liftexcessb/weight**2
    fbb = fbb + weightb
    auxb = (fixedmass+structuremass)*g*fbb
    tempb = endurance*tsfc*EXP(endurance*tsfc*(drag/l))*auxb/l
    lb = liftexcessb/weight - drag*tempb/l
    structuremassb = g*weightb + (aux-1)*g*fbb
    dragb = tempb
    dib = dragb
    srefb = rhoair*cd0*SUM(vinf**2)*dragb/2
    ksmarginb = loadfactor*ksmarginb
    marginsb = loadfactor*marginsb
    CALL POPREAL4ARRAY(margins, 2*n_panels)
    CALL FEM_MAIN_B(n_panels, n_cons, xfem, r, t, tb, f, fb0, d, db, e, &
&             rhomat, sigmay, pks, conids, resfem, resfemb, &
&             structuremass, structuremassb, margins, marginsb, ksmargin&
&             , ksmarginb)
    CALL TRANSFER_FORCES_B(arg1, xfem, loads, loadsb, f, fb0)
    CALL POPINTEGER4(arg1)
    CALL TAPENADE_MAIN_B(n_panels, xllt, xlltb, gama, gamab, alpha0, &
&                  alpha0b, chords, cl0, cla, vinf, rhoair, resllt, &
&                  reslltb, sref, srefb, cl, cd, l, lb, di, dib, loads, &
&                  loadsb)
    CALL TRANSFER_DISPS_B(arg1, xfem, d, db, xllt, xlltb)
    liftexcessb = 0.0
    ksmarginb = 0.0
    fbb = 0.0
    resfemb = 0.0
    weightb = 0.0
  END SUBROUTINE ASA_ANALYSIS_B

!============================================================
  SUBROUTINE ASA_ANALYSIS(n_panels, n_cons, gama, alpha0, chords, xfem, &
&   r, t, d, cl0, cla, vinf, rhoair, e, rhomat, sigmay, pks, conids, cd0&
&   , fixedmass, g, endurance, tsfc, loadfactor, resllt, resfem, &
&   liftexcess, margins, ksmargin, fb, weight, sref, cl)
! This subroutine computes the residuals of the coupled aerostructural
! problem.
!
! INPUTS
!
! n_panels: integer -> Number of horseshoe panels and beams (the same).
! n_cons: integer -> Number of constrained DOFs.
! Gama: real(n_panels) -> Circulation intensity of each horseshoe vortex.
! alpha0: real(n_panels) -> Array of local incidence angles.
! chords: real(n_panels) -> Array of local chords.
! Xfem: real(3,n_panels+1) -> Coordinates of the undeformed beam nodes.
! r: real(n_panels) -> Radius of each beam element.
! t: real(n_panels) -> Wall thickness of each beam element.
! d: real(2*(n_panels+1)) -> Displacements values of all DOFs (including
!                           the constrained ones).
! cl0: real(n_panels) -> cl0 of each 2D section
! cla: real(n_panels) -> lift curve slope of each 2D section [1/rad]
! Vinf: real(3) -> Free-stream velocity vector
! rhoAir: real -> Air density
! E: real -> Young's module of the beam material.
! rhoMat: real -> Density of the beam material.
! sigmaY: real -> Yield stress of the beam material.
! pKS: real -> Constant of the KS functons used to aggregate stresses.
! conIDs: integer(n_cons) -> Indices of the DOFs of the Kf matrix that
!                            should be constrained.
! CD0: real -> Parasite drag that will be added to the induced drag.
! fixedMass: real -> Fixed mass of the aircraft less the wing structure.
! g: real -> Acceleration of gravity.
! Endurance: real -> Desired endurance of the aircraft.
! TSFC: real -> Thrust specific fuel consumption of the engine.
! loadFactor: real -> Factor applied to the structural failure margin
!                     to consider a multiplicative factor in the loads.
!
! OUTPUTS
!
! resllt: real(n_panels) -> Residuals of the LLT method
! resfem: real(2*(n_panels+1)) -> Residuals of the FEM model
!                                 considering all DOFs (including the
!                                 constrained ones). The residuals
!                                 of the constrained DOFs are the
!                                 displacements themselves, so that the
!                                 solver drives them to zero. We
!                                 modify the K matrix in appy_cons to
!                                 achieve that.
! liftExcess: real -> Difference between the generated lift and the.
!                     aircraft weight. This value is normalized:
!                     liftExcess = Lift/Weigth - 1
! margins: real(2*n_panels) -> Margin from Von Mises stress at each node
!                              with respect to the yield stress.
!                              The margins are computed as:
!                              margin = 1.0 - sigma_vm/sigmaY
!                              Negative margins indicate failure.
!                              Internal nodes have two values
!                              corresponding to the beam sections on
!                              either side. KSmargin is the aggregation of
!                              these values.
! KSmargin: real -> Aggregated safety margin. This value
!                   is a conservative estimate of the minimum
!                   margin value in the structure. This estimate
!                   gets closer to the real value as we increase
!                   pKS, but this may lead to numerical issues.
! FB: real -> Fuel burn (in Force units).
! Weight: real -> Total weight of the aircraft (in Force units)
!                 (fixed weight + structure weight + fuel weight)
! Sref: real -> Area of all panels
! CL: real -> Lift coefficient (adimensionalized by Sref)
    USE LLT_MODULE_DIFF, ONLY : tapenade_main
    USE FEM_MODULE_DIFF, ONLY : fem_main
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_panels, n_cons
    REAL, INTENT(IN) :: gama(n_panels), alpha0(n_panels)
    REAL, INTENT(IN) :: chords(n_panels)
    REAL, INTENT(IN) :: xfem(3, n_panels+1)
    REAL, INTENT(IN) :: r(n_panels), t(n_panels)
    REAL, INTENT(IN) :: d(2*(n_panels+1))
    REAL, INTENT(IN) :: cl0(n_panels), cla(n_panels), vinf(3), rhoair
    REAL, INTENT(IN) :: e, rhomat, sigmay, pks
    INTEGER, INTENT(IN) :: conids(n_cons)
    REAL, INTENT(IN) :: cd0, fixedmass, g, endurance, tsfc, loadfactor
! Output variables
    REAL, INTENT(OUT) :: resllt(n_panels), resfem(2*(n_panels+1))
    REAL, INTENT(OUT) :: liftexcess, margins(2*n_panels)
    REAL, INTENT(OUT) :: ksmargin, fb, weight, sref, cl
! Working variables
    REAL :: xllt(3, n_panels+1)
    REAL :: loads(n_panels), f(2*(n_panels+1))
    REAL :: cd, l, di, structuremass, drag, aux
    INTRINSIC SUM
    INTRINSIC EXP
    INTEGER :: arg1
! EXECUTION
    arg1 = n_panels + 1
    CALL TRANSFER_DISPS(arg1, xfem, d, xllt)
    CALL TAPENADE_MAIN(n_panels, xllt, gama, alpha0, chords, cl0, cla, &
&                vinf, rhoair, resllt, sref, cl, cd, l, di, loads)
    arg1 = n_panels + 1
    CALL TRANSFER_FORCES(arg1, xfem, loads, f)
    CALL FEM_MAIN(n_panels, n_cons, xfem, r, t, f, d, e, rhomat, sigmay&
&           , pks, conids, resfem, structuremass, margins, ksmargin)
    margins = loadfactor*margins + 1 - loadfactor
    ksmargin = ksmargin*loadfactor + 1 - loadfactor
    drag = di + rhoair*SUM(vinf*vinf)/2*sref*cd0
    aux = EXP(endurance*tsfc*drag/l)
    fb = g*(fixedmass+structuremass)*(aux-1)
    weight = g*(fixedmass+structuremass) + fb
    liftexcess = l/weight - 1
  END SUBROUTINE ASA_ANALYSIS

END MODULE ASA_MODULE_DIFF


