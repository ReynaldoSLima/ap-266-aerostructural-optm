!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.15 (master) - 15 Apr 2020 11:54
!
MODULE FEM_MODULE_DIFF
  IMPLICIT NONE
  REAL, PARAMETER :: zero=0.0
  REAL, PARAMETER :: pi=3.1415926535897932384626
  REAL, PARAMETER :: eps=EPSILON(zero)

CONTAINS
!  Differentiation of beam_stiffness_matrix in forward (tangent) mode:
!   variations   of useful results: ki ii
!   with respect to varying inputs: ti ki
  SUBROUTINE BEAM_STIFFNESS_MATRIX_D(x1i, x2i, ri, ti, tid, e, ki, kid, &
&   li, ii, iid)
    IMPLICIT NONE
! Input variables
    REAL, INTENT(IN) :: x1i(3), x2i(3), ri, ti, e
    REAL, INTENT(IN) :: tid
! Output variables
    REAL, INTENT(OUT) :: ki(4, 4), li, ii
    REAL, INTENT(OUT) :: kid(4, 4), iid
! Working variables
    REAL :: kk
    REAL :: kkd
    REAL :: temp
! EXECUTION
! Compute the length of the beam
    li = x2i(2) - x1i(2)
! Compute the moment of inertia of a circular beam
    temp = ri*ri*ri
    iid = temp*pi*tid
    ii = temp*(pi*ti)
! Compute the bending term that is common to all elements
! of the stiffness matrix
    temp = li*li*li
    kkd = e*iid/temp
    kk = e*(ii/temp)
! Populate the stiffness matrix
    kid(1, 1) = 12*kkd
    ki(1, 1) = 12*kk
    kid(1, 2) = li*6*kkd
    ki(1, 2) = 6*li*kk
    kid(1, 3) = -(12*kkd)
    ki(1, 3) = -(12*kk)
    kid(1, 4) = li*6*kkd
    ki(1, 4) = 6*li*kk
    kid(2, 1) = li*6*kkd
    ki(2, 1) = 6*li*kk
    kid(2, 2) = li**2*4*kkd
    ki(2, 2) = 4*li**2*kk
    kid(2, 3) = -(li*6*kkd)
    ki(2, 3) = -(6*li*kk)
    kid(2, 4) = li**2*2*kkd
    ki(2, 4) = 2*li**2*kk
    kid(3, 1) = -(12*kkd)
    ki(3, 1) = -(12*kk)
    kid(3, 2) = -(li*6*kkd)
    ki(3, 2) = -(6*li*kk)
    kid(3, 3) = 12*kkd
    ki(3, 3) = 12*kk
    kid(3, 4) = -(li*6*kkd)
    ki(3, 4) = -(6*li*kk)
    kid(4, 1) = li*6*kkd
    ki(4, 1) = 6*li*kk
    kid(4, 2) = li**2*2*kkd
    ki(4, 2) = 2*li**2*kk
    kid(4, 3) = -(li*6*kkd)
    ki(4, 3) = -(6*li*kk)
    kid(4, 4) = li**2*4*kkd
    ki(4, 4) = 4*li**2*kk
  END SUBROUTINE BEAM_STIFFNESS_MATRIX_D

!  Differentiation of beam_stiffness_matrix in reverse (adjoint) mode:
!   gradient     of useful results: ti ki ii
!   with respect to varying inputs: ti ki
  SUBROUTINE BEAM_STIFFNESS_MATRIX_B(x1i, x2i, ri, ti, tib, e, ki, kib, &
&   li, ii, iib)
    IMPLICIT NONE
! Input variables
    REAL, INTENT(IN) :: x1i(3), x2i(3), ri, ti, e
    REAL :: tib
! Output variables
    REAL :: ki(4, 4), li, ii
    REAL :: kib(4, 4), iib
! Working variables
    REAL :: kk
    REAL :: kkb
! EXECUTION
! Compute the length of the beam
    CALL PUSHREAL4(li)
    li = x2i(2) - x1i(2)
! Compute the moment of inertia of a circular beam
    CALL PUSHREAL4(ii)
    ii = pi*ri**3*ti
! Compute the bending term that is common to all elements
! of the stiffness matrix
    kk = e*ii/li**3
! Populate the stiffness matrix
    CALL PUSHREAL4(ki(1, 1))
    ki(1, 1) = 12*kk
    CALL PUSHREAL4(ki(1, 2))
    ki(1, 2) = 6*li*kk
    CALL PUSHREAL4(ki(1, 3))
    ki(1, 3) = -(12*kk)
    CALL PUSHREAL4(ki(1, 4))
    ki(1, 4) = 6*li*kk
    CALL PUSHREAL4(ki(2, 1))
    ki(2, 1) = 6*li*kk
    CALL PUSHREAL4(ki(2, 2))
    ki(2, 2) = 4*li**2*kk
    CALL PUSHREAL4(ki(2, 3))
    ki(2, 3) = -(6*li*kk)
    CALL PUSHREAL4(ki(2, 4))
    ki(2, 4) = 2*li**2*kk
    CALL PUSHREAL4(ki(3, 1))
    ki(3, 1) = -(12*kk)
    CALL PUSHREAL4(ki(3, 2))
    ki(3, 2) = -(6*li*kk)
    CALL PUSHREAL4(ki(3, 3))
    ki(3, 3) = 12*kk
    CALL PUSHREAL4(ki(3, 4))
    ki(3, 4) = -(6*li*kk)
    CALL PUSHREAL4(ki(4, 1))
    ki(4, 1) = 6*li*kk
    CALL PUSHREAL4(ki(4, 2))
    ki(4, 2) = 2*li**2*kk
    CALL PUSHREAL4(ki(4, 3))
    ki(4, 3) = -(6*li*kk)
    CALL PUSHREAL4(ki(4, 4))
    ki(4, 4) = 4*li**2*kk
    CALL POPREAL4(ki(4, 4))
    kkb = 4*li**2*kib(4, 4) + 2*li**2*kib(4, 2) - li*6*kib(4, 3) + li*6*&
&     kib(4, 1) + 12*kib(3, 3) - li*6*kib(3, 4) + 2*li**2*kib(2, 4) - li&
&     *6*kib(3, 2) - 12*kib(3, 1) + 4*li**2*kib(2, 2) - li*6*kib(2, 3) +&
&     li*6*kib(2, 1) + li*6*kib(1, 4) + li*6*kib(1, 2) - 12*kib(1, 3) + &
&     12*kib(1, 1)
    kib(4, 4) = 0.0
    CALL POPREAL4(ki(4, 3))
    kib(4, 3) = 0.0
    CALL POPREAL4(ki(4, 2))
    kib(4, 2) = 0.0
    CALL POPREAL4(ki(4, 1))
    kib(4, 1) = 0.0
    CALL POPREAL4(ki(3, 4))
    kib(3, 4) = 0.0
    CALL POPREAL4(ki(3, 3))
    kib(3, 3) = 0.0
    CALL POPREAL4(ki(3, 2))
    kib(3, 2) = 0.0
    CALL POPREAL4(ki(3, 1))
    kib(3, 1) = 0.0
    CALL POPREAL4(ki(2, 4))
    kib(2, 4) = 0.0
    CALL POPREAL4(ki(2, 3))
    kib(2, 3) = 0.0
    CALL POPREAL4(ki(2, 2))
    kib(2, 2) = 0.0
    CALL POPREAL4(ki(2, 1))
    kib(2, 1) = 0.0
    CALL POPREAL4(ki(1, 4))
    kib(1, 4) = 0.0
    CALL POPREAL4(ki(1, 3))
    kib(1, 3) = 0.0
    CALL POPREAL4(ki(1, 2))
    kib(1, 2) = 0.0
    CALL POPREAL4(ki(1, 1))
    kib(1, 1) = 0.0
    iib = iib + e*kkb/li**3
    CALL POPREAL4(ii)
    tib = tib + pi*ri**3*iib
    CALL POPREAL4(li)
  END SUBROUTINE BEAM_STIFFNESS_MATRIX_B

  SUBROUTINE BEAM_STIFFNESS_MATRIX(x1i, x2i, ri, ti, e, ki, li, ii)
    IMPLICIT NONE
! Input variables
    REAL, INTENT(IN) :: x1i(3), x2i(3), ri, ti, e
! Output variables
    REAL, INTENT(OUT) :: ki(4, 4), li, ii
! Working variables
    REAL :: kk
! EXECUTION
! Compute the length of the beam
    li = x2i(2) - x1i(2)
! Compute the moment of inertia of a circular beam
    ii = pi*ri**3*ti
! Compute the bending term that is common to all elements
! of the stiffness matrix
    kk = e*ii/li**3
! Populate the stiffness matrix
    ki(1, 1) = 12*kk
    ki(1, 2) = 6*li*kk
    ki(1, 3) = -(12*kk)
    ki(1, 4) = 6*li*kk
    ki(2, 1) = 6*li*kk
    ki(2, 2) = 4*li**2*kk
    ki(2, 3) = -(6*li*kk)
    ki(2, 4) = 2*li**2*kk
    ki(3, 1) = -(12*kk)
    ki(3, 2) = -(6*li*kk)
    ki(3, 3) = 12*kk
    ki(3, 4) = -(6*li*kk)
    ki(4, 1) = 6*li*kk
    ki(4, 2) = 2*li**2*kk
    ki(4, 3) = -(6*li*kk)
    ki(4, 4) = 4*li**2*kk
  END SUBROUTINE BEAM_STIFFNESS_MATRIX

!  Differentiation of get_k_matrix in forward (tangent) mode:
!   variations   of useful results: k
!   with respect to varying inputs: t
!============================================================
  SUBROUTINE GET_K_MATRIX_D(n_beams, x, r, t, td, e, k, kd, n_dofs)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_beams
    REAL, INTENT(IN) :: x(3, n_beams+1)
    REAL, INTENT(IN) :: r(n_beams), t(n_beams), e
    REAL, INTENT(IN) :: td(n_beams)
! Output variables
    REAL, INTENT(OUT) :: k(2*(n_beams+1), 2*(n_beams+1))
    REAL, INTENT(OUT) :: kd(2*(n_beams+1), 2*(n_beams+1))
    INTEGER, INTENT(OUT) :: n_dofs
! Working variables
    INTEGER :: jj
    REAL :: x1i(3), x2i(3), ki(4, 4), li, ii
    REAL :: kid(4, 4), iid
! EXECUTION
! Initialize the stifness matrix
    k = zero
    kd = 0.0
    kid = 0.0
! Loop over all beams
    DO jj=1,n_beams
! Get nodal coordinates of the current beam
      x1i = x(:, jj)
      x2i = x(:, jj+1)
! Compute the element stiffness matrix
      CALL BEAM_STIFFNESS_MATRIX_D(x1i, x2i, r(jj), t(jj), td(jj), e, ki&
&                            , kid, li, ii, iid)
! Assign the element matrix to the global matrix
      kd(2*jj-1:2*jj+2, 2*jj-1:2*jj+2) = kd(2*jj-1:2*jj+2, 2*jj-1:2*jj+2&
&       ) + kid
      k(2*jj-1:2*jj+2, 2*jj-1:2*jj+2) = k(2*jj-1:2*jj+2, 2*jj-1:2*jj+2) &
&       + ki
    END DO
! Compute number of degrees of freedom
    n_dofs = 2*(n_beams+1)
  END SUBROUTINE GET_K_MATRIX_D

!  Differentiation of get_k_matrix in reverse (adjoint) mode:
!   gradient     of useful results: k t
!   with respect to varying inputs: t
!============================================================
  SUBROUTINE GET_K_MATRIX_B(n_beams, x, r, t, tb, e, k, kb, n_dofs)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_beams
    REAL, INTENT(IN) :: x(3, n_beams+1)
    REAL, INTENT(IN) :: r(n_beams), t(n_beams), e
    REAL :: tb(n_beams)
! Output variables
    REAL :: k(2*(n_beams+1), 2*(n_beams+1))
    REAL :: kb(2*(n_beams+1), 2*(n_beams+1))
    INTEGER, INTENT(OUT) :: n_dofs
! Working variables
    INTEGER :: jj
    REAL :: x1i(3), x2i(3), ki(4, 4), li, ii
    REAL :: kib(4, 4), iib
! EXECUTION
! Initialize the stifness matrix
    k = zero
! Loop over all beams
    DO jj=1,n_beams
! Get nodal coordinates of the current beam
      CALL PUSHREAL4ARRAY(x1i, 3)
      x1i = x(:, jj)
      CALL PUSHREAL4ARRAY(x2i, 3)
      x2i = x(:, jj+1)
! Compute the element stiffness matrix
      CALL BEAM_STIFFNESS_MATRIX(x1i, x2i, r(jj), t(jj), e, ki, li, ii)
! Assign the element matrix to the global matrix
      k(2*jj-1:2*jj+2, 2*jj-1:2*jj+2) = k(2*jj-1:2*jj+2, 2*jj-1:2*jj+2) &
&       + ki
    END DO
! Compute number of degrees of freedom
    n_dofs = 2*(n_beams+1)
    kib = 0.0
    DO jj=n_beams,1,-1
      kib = kib + kb(2*jj-1:2*jj+2, 2*jj-1:2*jj+2)
      iib = 0.0
      CALL BEAM_STIFFNESS_MATRIX_B(x1i, x2i, r(jj), t(jj), tb(jj), e, ki&
&                            , kib, li, ii, iib)
      CALL POPREAL4ARRAY(x2i, 3)
      CALL POPREAL4ARRAY(x1i, 3)
    END DO
  END SUBROUTINE GET_K_MATRIX_B

!============================================================
  SUBROUTINE GET_K_MATRIX(n_beams, x, r, t, e, k, n_dofs)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_beams
    REAL, INTENT(IN) :: x(3, n_beams+1)
    REAL, INTENT(IN) :: r(n_beams), t(n_beams), e
! Output variables
    REAL, INTENT(OUT) :: k(2*(n_beams+1), 2*(n_beams+1))
    INTEGER, INTENT(OUT) :: n_dofs
! Working variables
    INTEGER :: jj
    REAL :: x1i(3), x2i(3), ki(4, 4), li, ii
! EXECUTION
! Initialize the stifness matrix
    k = zero
! Loop over all beams
    DO jj=1,n_beams
! Get nodal coordinates of the current beam
      x1i = x(:, jj)
      x2i = x(:, jj+1)
! Compute the element stiffness matrix
      CALL BEAM_STIFFNESS_MATRIX(x1i, x2i, r(jj), t(jj), e, ki, li, ii)
! Assign the element matrix to the global matrix
      k(2*jj-1:2*jj+2, 2*jj-1:2*jj+2) = k(2*jj-1:2*jj+2, 2*jj-1:2*jj+2) &
&       + ki
    END DO
! Compute number of degrees of freedom
    n_dofs = 2*(n_beams+1)
  END SUBROUTINE GET_K_MATRIX

!  Differentiation of apply_cons in forward (tangent) mode:
!   variations   of useful results: f k
!   with respect to varying inputs: f k
!============================================================
  SUBROUTINE APPLY_CONS_D(n_dofs, n_cons, conids, k, kd, f, fd)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_dofs, n_cons
    INTEGER, INTENT(IN) :: conids(n_cons)
! Output variables
    REAL, INTENT(INOUT) :: k(n_dofs, n_dofs)
    REAL, INTENT(INOUT) :: kd(n_dofs, n_dofs)
    REAL, INTENT(INOUT) :: f(n_dofs)
    REAL, INTENT(INOUT) :: fd(n_dofs)
! Working variables
    INTEGER :: ii, curr_con
! EXECUTION
! First we will create the array freeIDs containing all indices
! of the free DOFs. Then we will use this array to crop Kf and ff.
! Now we set the indices of the constrained DOFs to zero
    DO ii=1,n_cons
      curr_con = conids(ii)
! We will modify K and f so that d(curr_con) is forced to be zero.
! We can do that by setting:
! f(curr_con)=0, K(curr_con,:)=0, K(:,curr_con)=1,
! and K(curr_con,curr_con)=1.
! Modify the K matrix
      kd(curr_con, :) = 0.0
      k(curr_con, :) = 0.0
      kd(:, curr_con) = 0.0
      k(:, curr_con) = 0.0
      kd(curr_con, curr_con) = 0.0
      k(curr_con, curr_con) = 1.0
! Modify the f vector
      fd(curr_con) = 0.0
      f(curr_con) = 0.0
    END DO
  END SUBROUTINE APPLY_CONS_D

!  Differentiation of apply_cons in reverse (adjoint) mode:
!   gradient     of useful results: f k
!   with respect to varying inputs: f k
!============================================================
  SUBROUTINE APPLY_CONS_B(n_dofs, n_cons, conids, k, kb, f, fb)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_dofs, n_cons
    INTEGER, INTENT(IN) :: conids(n_cons)
! Output variables
    REAL, INTENT(INOUT) :: k(n_dofs, n_dofs)
    REAL, INTENT(INOUT) :: kb(n_dofs, n_dofs)
    REAL, INTENT(INOUT) :: f(n_dofs)
    REAL, INTENT(INOUT) :: fb(n_dofs)
! Working variables
    INTEGER :: ii, curr_con
! EXECUTION
! First we will create the array freeIDs containing all indices
! of the free DOFs. Then we will use this array to crop Kf and ff.
! Now we set the indices of the constrained DOFs to zero
    DO ii=1,n_cons
      CALL PUSHINTEGER4(curr_con)
      curr_con = conids(ii)
! We will modify K and f so that d(curr_con) is forced to be zero.
! We can do that by setting:
! f(curr_con)=0, K(curr_con,:)=0, K(:,curr_con)=1,
! and K(curr_con,curr_con)=1.
! Modify the K matrix
      k(curr_con, :) = 0.0
      k(:, curr_con) = 0.0
      k(curr_con, curr_con) = 1.0
! Modify the f vector
      f(curr_con) = 0.0
    END DO
    DO ii=n_cons,1,-1
      fb(curr_con) = 0.0
      kb(curr_con, curr_con) = 0.0
      kb(:, curr_con) = 0.0
      kb(curr_con, :) = 0.0
      CALL POPINTEGER4(curr_con)
    END DO
  END SUBROUTINE APPLY_CONS_B

!============================================================
  SUBROUTINE APPLY_CONS(n_dofs, n_cons, conids, k, f)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_dofs, n_cons
    INTEGER, INTENT(IN) :: conids(n_cons)
! Output variables
    REAL, INTENT(INOUT) :: k(n_dofs, n_dofs)
    REAL, INTENT(INOUT) :: f(n_dofs)
! Working variables
    INTEGER :: ii, curr_con
! EXECUTION
! First we will create the array freeIDs containing all indices
! of the free DOFs. Then we will use this array to crop Kf and ff.
! Now we set the indices of the constrained DOFs to zero
    DO ii=1,n_cons
      curr_con = conids(ii)
! We will modify K and f so that d(curr_con) is forced to be zero.
! We can do that by setting:
! f(curr_con)=0, K(curr_con,:)=0, K(:,curr_con)=1,
! and K(curr_con,curr_con)=1.
! Modify the K matrix
      k(curr_con, :) = 0.0
      k(:, curr_con) = 0.0
      k(curr_con, curr_con) = 1.0
! Modify the f vector
      f(curr_con) = 0.0
    END DO
  END SUBROUTINE APPLY_CONS

!  Differentiation of get_residuals in forward (tangent) mode:
!   variations   of useful results: res
!   with respect to varying inputs: d f t
!============================================================
  SUBROUTINE GET_RESIDUALS_D0(n_beams, n_cons, x, r, t, td, f, fd, d, dd&
&   , e, conids, res, resd)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_beams, n_cons
    REAL, INTENT(IN) :: x(3, n_beams+1)
    REAL, INTENT(IN) :: r(n_beams), t(n_beams)
    REAL, INTENT(IN) :: td(n_beams)
    REAL, INTENT(IN) :: f(2*(n_beams+1)), d(2*(n_beams+1)), e
    REAL, INTENT(IN) :: fd(2*(n_beams+1)), dd(2*(n_beams+1))
    INTEGER, INTENT(IN) :: conids(n_cons)
! Output variables
    REAL, INTENT(OUT) :: res(2*(n_beams+1))
    REAL, INTENT(OUT) :: resd(2*(n_beams+1))
! Working variables
    REAL :: k(2*(n_beams+1), 2*(n_beams+1)), fcopy(2*(n_beams+1))
    REAL :: kd0(2*(n_beams+1), 2*(n_beams+1)), fcopyd(2*(n_beams+1))
    REAL :: kd(2*(n_beams+1))
    REAL :: kdd(2*(n_beams+1))
    INTEGER :: n_dofs
! EXECUTION
! Build the full stiffness matrix
    CALL GET_K_MATRIX_D(n_beams, x, r, t, td, e, k, kd0, n_dofs)
! Make a copy of the force vector so we can modify its elements
    fcopyd = fd
    fcopy = f
! Apply the constraints
    CALL APPLY_CONS_D(n_dofs, n_cons, conids, k, kd0, fcopy, fcopyd)
! Compute K*d
    CALL MATDOTVEC_D(n_dofs, k, kd0, d, dd, kd, kdd)
! Compute the residuals
    resd = kdd - fcopyd
    res = kd - fcopy
  END SUBROUTINE GET_RESIDUALS_D0

!  Differentiation of get_residuals in reverse (adjoint) mode:
!   gradient     of useful results: res d t
!   with respect to varying inputs: d f t
!============================================================
  SUBROUTINE GET_RESIDUALS_B0(n_beams, n_cons, x, r, t, tb, f, fb, d, db&
&   , e, conids, res, resb)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_beams, n_cons
    REAL, INTENT(IN) :: x(3, n_beams+1)
    REAL, INTENT(IN) :: r(n_beams), t(n_beams)
    REAL :: tb(n_beams)
    REAL, INTENT(IN) :: f(2*(n_beams+1)), d(2*(n_beams+1)), e
    REAL :: fb(2*(n_beams+1)), db(2*(n_beams+1))
    INTEGER, INTENT(IN) :: conids(n_cons)
! Output variables
    REAL :: res(2*(n_beams+1))
    REAL :: resb(2*(n_beams+1))
! Working variables
    REAL :: k(2*(n_beams+1), 2*(n_beams+1)), fcopy(2*(n_beams+1))
    REAL :: kb(2*(n_beams+1), 2*(n_beams+1)), fcopyb(2*(n_beams+1))
    REAL :: kd(2*(n_beams+1))
    REAL :: kdb(2*(n_beams+1))
    INTEGER :: n_dofs
! EXECUTION
! Build the full stiffness matrix
    CALL GET_K_MATRIX(n_beams, x, r, t, e, k, n_dofs)
! Make a copy of the force vector so we can modify its elements
    fcopy = f
! Apply the constraints
    CALL APPLY_CONS(n_dofs, n_cons, conids, k, fcopy)
! Compute K*d
    CALL MATDOTVEC(n_dofs, k, d, kd)
! Compute the residuals
    res = kd - fcopy
    fcopyb = 0.0
    kdb = 0.0
    kdb = resb
    fcopyb = -resb
    kb = 0.0
    CALL MATDOTVEC_B(n_dofs, k, kb, d, db, kd, kdb)
    CALL APPLY_CONS_B(n_dofs, n_cons, conids, k, kb, fcopy, fcopyb)
    fb = 0.0
    fb = fcopyb
    CALL GET_K_MATRIX_B(n_beams, x, r, t, tb, e, k, kb, n_dofs)
  END SUBROUTINE GET_RESIDUALS_B0

!============================================================
  SUBROUTINE GET_RESIDUALS(n_beams, n_cons, x, r, t, f, d, e, conids, &
&   res)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_beams, n_cons
    REAL, INTENT(IN) :: x(3, n_beams+1)
    REAL, INTENT(IN) :: r(n_beams), t(n_beams)
    REAL, INTENT(IN) :: f(2*(n_beams+1)), d(2*(n_beams+1)), e
    INTEGER, INTENT(IN) :: conids(n_cons)
! Output variables
    REAL, INTENT(OUT) :: res(2*(n_beams+1))
! Working variables
    REAL :: k(2*(n_beams+1), 2*(n_beams+1)), fcopy(2*(n_beams+1))
    REAL :: kd(2*(n_beams+1))
    INTEGER :: n_dofs
! EXECUTION
! Build the full stiffness matrix
    CALL GET_K_MATRIX(n_beams, x, r, t, e, k, n_dofs)
! Make a copy of the force vector so we can modify its elements
    fcopy = f
! Apply the constraints
    CALL APPLY_CONS(n_dofs, n_cons, conids, k, fcopy)
! Compute K*d
    CALL MATDOTVEC(n_dofs, k, d, kd)
! Compute the residuals
    res = kd - fcopy
  END SUBROUTINE GET_RESIDUALS

!  Differentiation of get_functions in forward (tangent) mode:
!   variations   of useful results: mass ksmargin margins
!   with respect to varying inputs: d t margins
!============================================================
  SUBROUTINE GET_FUNCTIONS_D0(n_beams, n_cons, x, r, t, td, f, d, dd, e&
&   , rho, sigmay, pks, conids, mass, massd, margins, marginsd, ksmargin&
&   , ksmargind)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_beams, n_cons
    REAL, INTENT(IN) :: x(3, n_beams+1)
    REAL, INTENT(IN) :: r(n_beams), t(n_beams)
    REAL, INTENT(IN) :: td(n_beams)
    REAL, INTENT(IN) :: f(2*(n_beams+1)), d(2*(n_beams+1))
    REAL, INTENT(IN) :: dd(2*(n_beams+1))
    REAL, INTENT(IN) :: e, rho, sigmay, pks
    INTEGER, INTENT(IN) :: conids(n_cons)
! Output variables
    REAL, INTENT(OUT) :: mass, margins(2*n_beams), ksmargin
    REAL, INTENT(OUT) :: massd, marginsd(2*n_beams), ksmargind
! Working variables
    REAL :: k(2*(n_beams+1), 2*(n_beams+1)), fcopy(2*(n_beams+1))
    REAL :: kd(2*(n_beams+1))
    REAL :: x1i(3), x2i(3), ki(4, 4), li, ii, di(4), fi(4), ai
    REAL :: kid(4, 4), iid, did(4), fid(4), aid
    REAL :: sigma1, sigma2, tau, sigma_vm1, sigma_vm2
    REAL :: sigma1d, sigma2d, taud, sigma_vm1d, sigma_vm2d
    REAL :: margin_min, margin_sum
    REAL :: margin_sumd
    INTEGER :: n_dofs, jj
    INTRINSIC SQRT
    INTRINSIC EXP
    INTRINSIC SUM
    INTRINSIC LOG
    REAL :: temp
    REAL :: temp0
! EXECUTION
! Initialize the mass value
    mass = 0
    massd = 0.0
    kid = 0.0
! Loop over every element to compute contributions of mass and stress
    DO jj=1,n_beams
! Get nodal coordinates of the current beam
      x1i = x(:, jj)
      x2i = x(:, jj+1)
! Get element properties
      CALL BEAM_STIFFNESS_MATRIX_D(x1i, x2i, r(jj), t(jj), td(jj), e, ki&
&                            , kid, li, ii, iid)
! Compute section area
      aid = pi*2.0*r(jj)*td(jj)
      ai = 2.0*pi*r(jj)*t(jj)
! Compute mass contribution
      massd = massd + rho*li*aid
      mass = mass + rho*ai*li
! Get DOF values of the current nodes
      did = dd(2*jj-1:2*jj+2)
      di = d(2*jj-1:2*jj+2)
! Compute corresponding local nodal forces
      CALL MATDOTVEC_D(4, ki, kid, di, did, fi, fid)
! Compute bending stress on node 1 (sigma = M*y/I)
      temp = fi(2)/ii
      sigma1d = r(jj)*(fid(2)-temp*iid)/ii
      sigma1 = r(jj)*temp
! Compute bending stress on node 2 (sigma = M*y/I)
      temp = fi(4)/ii
      sigma2d = r(jj)*(fid(4)-temp*iid)/ii
      sigma2 = r(jj)*temp
! Compute shear stress on the beam (it is constant)
! We need 2.0 because shear is maximum at the midplane
      temp = fi(1)/ai
      taud = 2.0*(fid(1)-temp*aid)/ai
      tau = 2.0*temp
! Compute the Von Mises stress for each node
! This is a conservative measure, since we are using the
! maximum bending stress and the maximum shear stress, even though
! they are at different locations of the cross-section.
      temp = sigma1*sigma1 + 3.0*(tau*tau)
      temp0 = SQRT(temp)
      IF (temp .EQ. 0.0) THEN
        sigma_vm1d = 0.0
      ELSE
        sigma_vm1d = (2*sigma1*sigma1d+3.0*2*tau*taud)/(2.0*temp0)
      END IF
      sigma_vm1 = temp0
      temp0 = sigma2*sigma2 + 3.0*(tau*tau)
      temp = SQRT(temp0)
      IF (temp0 .EQ. 0.0) THEN
        sigma_vm2d = 0.0
      ELSE
        sigma_vm2d = (2*sigma2*sigma2d+3.0*2*tau*taud)/(2.0*temp)
      END IF
      sigma_vm2 = temp
! Compute the safety margin with respect to the failure
      marginsd(2*jj-1) = -(sigma_vm1d/sigmay)
      margins(2*jj-1) = 1.0 - sigma_vm1/sigmay
      marginsd(2*jj) = -(sigma_vm2d/sigmay)
      margins(2*jj) = 1.0 - sigma_vm2/sigmay
    END DO
! The KS function estimates the maximum value from the set.
! But the minimum margin is the most critical one.
! So we flip the sign of the margins to
! compute the KS value.
! Find the minimum safety margin (most critical case)
! NOTE: I deactivated this since the changes in the minimum values
! caused discrepancies with respect to the finite difference test
! when checking derivatives.
!1.0
    margin_min = 0.0
!do jj=1,2*n_beams
!   margin_min = min(margin_min, margins(jj))
!end do
! Compute sum of the KS expression inside the natural logarithm.
! Note that we flipped the margins signs.
    margin_sumd = SUM(-(EXP(pks*(margin_min-margins))*pks*marginsd))
    margin_sum = SUM(EXP(pks*(-margins+margin_min)))
! Aggregate stresses
    ksmargind = -(margin_sumd/(pks*margin_sum))
    ksmargin = margin_min - 1.0/pks*LOG(margin_sum)
  END SUBROUTINE GET_FUNCTIONS_D0

!  Differentiation of get_functions in reverse (adjoint) mode:
!   gradient     of useful results: mass ksmargin margins
!   with respect to varying inputs: d t margins
!============================================================
  SUBROUTINE GET_FUNCTIONS_B0(n_beams, n_cons, x, r, t, tb, f, d, db, e&
&   , rho, sigmay, pks, conids, mass, massb, margins, marginsb, ksmargin&
&   , ksmarginb)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_beams, n_cons
    REAL, INTENT(IN) :: x(3, n_beams+1)
    REAL, INTENT(IN) :: r(n_beams), t(n_beams)
    REAL :: tb(n_beams)
    REAL, INTENT(IN) :: f(2*(n_beams+1)), d(2*(n_beams+1))
    REAL :: db(2*(n_beams+1))
    REAL, INTENT(IN) :: e, rho, sigmay, pks
    INTEGER, INTENT(IN) :: conids(n_cons)
! Output variables
    REAL :: mass, margins(2*n_beams), ksmargin
    REAL :: massb, marginsb(2*n_beams), ksmarginb
! Working variables
    REAL :: k(2*(n_beams+1), 2*(n_beams+1)), fcopy(2*(n_beams+1))
    REAL :: kd(2*(n_beams+1))
    REAL :: x1i(3), x2i(3), ki(4, 4), li, ii, di(4), fi(4), ai
    REAL :: kib(4, 4), iib, dib(4), fib(4), aib
    REAL :: sigma1, sigma2, tau, sigma_vm1, sigma_vm2
    REAL :: sigma1b, sigma2b, taub, sigma_vm1b, sigma_vm2b
    REAL :: margin_min, margin_sum
    REAL :: margin_sumb
    INTEGER :: n_dofs, jj
    INTRINSIC SQRT
    INTRINSIC EXP
    INTRINSIC SUM
    INTRINSIC LOG
    REAL :: tempb
! EXECUTION
! Initialize the mass value
    mass = 0
! Loop over every element to compute contributions of mass and stress
    DO jj=1,n_beams
! Get nodal coordinates of the current beam
      CALL PUSHREAL4ARRAY(x1i, 3)
      x1i = x(:, jj)
      CALL PUSHREAL4ARRAY(x2i, 3)
      x2i = x(:, jj+1)
! Get element properties
      CALL PUSHREAL4(ii)
      CALL PUSHREAL4(li)
      CALL PUSHREAL4ARRAY(ki, 4**2)
      CALL BEAM_STIFFNESS_MATRIX(x1i, x2i, r(jj), t(jj), e, ki, li, ii)
! Compute section area
      CALL PUSHREAL4(ai)
      ai = 2.0*pi*r(jj)*t(jj)
! Compute mass contribution
      mass = mass + rho*ai*li
! Get DOF values of the current nodes
      CALL PUSHREAL4ARRAY(di, 4)
      di = d(2*jj-1:2*jj+2)
! Compute corresponding local nodal forces
      CALL PUSHREAL4ARRAY(fi, 4)
      CALL MATDOTVEC(4, ki, di, fi)
! Compute bending stress on node 1 (sigma = M*y/I)
      CALL PUSHREAL4(sigma1)
      sigma1 = fi(2)*r(jj)/ii
! Compute bending stress on node 2 (sigma = M*y/I)
      CALL PUSHREAL4(sigma2)
      sigma2 = fi(4)*r(jj)/ii
! Compute shear stress on the beam (it is constant)
! We need 2.0 because shear is maximum at the midplane
      CALL PUSHREAL4(tau)
      tau = 2.0*fi(1)/ai
! Compute the Von Mises stress for each node
! This is a conservative measure, since we are using the
! maximum bending stress and the maximum shear stress, even though
! they are at different locations of the cross-section.
      sigma_vm1 = SQRT(sigma1**2 + 3.0*tau**2)
      sigma_vm2 = SQRT(sigma2**2 + 3.0*tau**2)
! Compute the safety margin with respect to the failure
      margins(2*jj-1) = 1.0 - sigma_vm1/sigmay
      margins(2*jj) = 1.0 - sigma_vm2/sigmay
    END DO
! The KS function estimates the maximum value from the set.
! But the minimum margin is the most critical one.
! So we flip the sign of the margins to
! compute the KS value.
! Find the minimum safety margin (most critical case)
! NOTE: I deactivated this since the changes in the minimum values
! caused discrepancies with respect to the finite difference test
! when checking derivatives.
!1.0
    margin_min = 0.0
!do jj=1,2*n_beams
!   margin_min = min(margin_min, margins(jj))
!end do
! Compute sum of the KS expression inside the natural logarithm.
! Note that we flipped the margins signs.
    margin_sum = SUM(EXP(pks*(-margins+margin_min)))
! Aggregate stresses
    ksmargin = margin_min - 1.0/pks*LOG(margin_sum)
    margin_sumb = -(ksmarginb/(margin_sum*pks))
    marginsb = marginsb - pks*EXP(pks*(margin_min-margins))*margin_sumb
    db = 0.0
    tb = 0.0
    kib = 0.0
    DO jj=n_beams,1,-1
      sigma_vm2b = -(marginsb(2*jj)/sigmay)
      marginsb(2*jj) = 0.0
      sigma_vm1b = -(marginsb(2*jj-1)/sigmay)
      marginsb(2*jj-1) = 0.0
      IF (sigma2**2 + 3.0*tau**2 .EQ. 0.0) THEN
        tempb = 0.0
      ELSE
        tempb = sigma_vm2b/(2.0*SQRT(sigma2**2+3.0*tau**2))
      END IF
      sigma2b = 2*sigma2*tempb
      taub = 2*tau*3.0*tempb
      IF (sigma1**2 + 3.0*tau**2 .EQ. 0.0) THEN
        tempb = 0.0
      ELSE
        tempb = sigma_vm1b/(2.0*SQRT(sigma1**2+3.0*tau**2))
      END IF
      sigma1b = 2*sigma1*tempb
      taub = taub + 2*tau*3.0*tempb
      fib = 0.0
      CALL POPREAL4(tau)
      tempb = 2.0*taub/ai
      fib(1) = fib(1) + tempb
      aib = rho*li*massb - fi(1)*tempb/ai
      CALL POPREAL4(sigma2)
      tempb = r(jj)*sigma2b/ii
      fib(4) = fib(4) + tempb
      iib = -(fi(4)*tempb/ii)
      CALL POPREAL4(sigma1)
      tempb = r(jj)*sigma1b/ii
      fib(2) = fib(2) + tempb
      iib = iib - fi(2)*tempb/ii
      CALL POPREAL4ARRAY(fi, 4)
      dib = 0.0
      CALL MATDOTVEC_B(4, ki, kib, di, dib, fi, fib)
      CALL POPREAL4ARRAY(di, 4)
      db(2*jj-1:2*jj+2) = db(2*jj-1:2*jj+2) + dib
      CALL POPREAL4(ai)
      tb(jj) = tb(jj) + r(jj)*pi*2.0*aib
      CALL POPREAL4ARRAY(ki, 4**2)
      CALL POPREAL4(li)
      CALL POPREAL4(ii)
      CALL BEAM_STIFFNESS_MATRIX_B(x1i, x2i, r(jj), t(jj), tb(jj), e, ki&
&                            , kib, li, ii, iib)
      CALL POPREAL4ARRAY(x2i, 3)
      CALL POPREAL4ARRAY(x1i, 3)
    END DO
  END SUBROUTINE GET_FUNCTIONS_B0

!============================================================
  SUBROUTINE GET_FUNCTIONS(n_beams, n_cons, x, r, t, f, d, e, rho, &
&   sigmay, pks, conids, mass, margins, ksmargin)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_beams, n_cons
    REAL, INTENT(IN) :: x(3, n_beams+1)
    REAL, INTENT(IN) :: r(n_beams), t(n_beams)
    REAL, INTENT(IN) :: f(2*(n_beams+1)), d(2*(n_beams+1))
    REAL, INTENT(IN) :: e, rho, sigmay, pks
    INTEGER, INTENT(IN) :: conids(n_cons)
! Output variables
    REAL, INTENT(OUT) :: mass, margins(2*n_beams), ksmargin
! Working variables
    REAL :: k(2*(n_beams+1), 2*(n_beams+1)), fcopy(2*(n_beams+1))
    REAL :: kd(2*(n_beams+1))
    REAL :: x1i(3), x2i(3), ki(4, 4), li, ii, di(4), fi(4), ai
    REAL :: sigma1, sigma2, tau, sigma_vm1, sigma_vm2
    REAL :: margin_min, margin_sum
    INTEGER :: n_dofs, jj
    INTRINSIC SQRT
    INTRINSIC EXP
    INTRINSIC SUM
    INTRINSIC LOG
! EXECUTION
! Initialize the mass value
    mass = 0
! Loop over every element to compute contributions of mass and stress
    DO jj=1,n_beams
! Get nodal coordinates of the current beam
      x1i = x(:, jj)
      x2i = x(:, jj+1)
! Get element properties
      CALL BEAM_STIFFNESS_MATRIX(x1i, x2i, r(jj), t(jj), e, ki, li, ii)
! Compute section area
      ai = 2.0*pi*r(jj)*t(jj)
! Compute mass contribution
      mass = mass + rho*ai*li
! Get DOF values of the current nodes
      di = d(2*jj-1:2*jj+2)
! Compute corresponding local nodal forces
      CALL MATDOTVEC(4, ki, di, fi)
! Compute bending stress on node 1 (sigma = M*y/I)
      sigma1 = fi(2)*r(jj)/ii
! Compute bending stress on node 2 (sigma = M*y/I)
      sigma2 = fi(4)*r(jj)/ii
! Compute shear stress on the beam (it is constant)
! We need 2.0 because shear is maximum at the midplane
      tau = 2.0*fi(1)/ai
! Compute the Von Mises stress for each node
! This is a conservative measure, since we are using the
! maximum bending stress and the maximum shear stress, even though
! they are at different locations of the cross-section.
      sigma_vm1 = SQRT(sigma1**2 + 3.0*tau**2)
      sigma_vm2 = SQRT(sigma2**2 + 3.0*tau**2)
! Compute the safety margin with respect to the failure
      margins(2*jj-1) = 1.0 - sigma_vm1/sigmay
      margins(2*jj) = 1.0 - sigma_vm2/sigmay
    END DO
! The KS function estimates the maximum value from the set.
! But the minimum margin is the most critical one.
! So we flip the sign of the margins to
! compute the KS value.
! Find the minimum safety margin (most critical case)
! NOTE: I deactivated this since the changes in the minimum values
! caused discrepancies with respect to the finite difference test
! when checking derivatives.
!1.0
    margin_min = 0.0
!do jj=1,2*n_beams
!   margin_min = min(margin_min, margins(jj))
!end do
! Compute sum of the KS expression inside the natural logarithm.
! Note that we flipped the margins signs.
    margin_sum = SUM(EXP(pks*(-margins+margin_min)))
! Aggregate stresses
    ksmargin = margin_min - 1.0/pks*LOG(margin_sum)
  END SUBROUTINE GET_FUNCTIONS

!  Differentiation of matdotvec in forward (tangent) mode:
!   variations   of useful results: kd
!   with respect to varying inputs: d k
!============================================================
  SUBROUTINE MATDOTVEC_D(n, k, kd0, d, dd, kd, kdd)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n
    REAL, INTENT(IN) :: k(n, n), d(n)
    REAL, INTENT(IN) :: kd0(n, n), dd(n)
! Output variables
    REAL, INTENT(OUT) :: kd(n)
    REAL, INTENT(OUT) :: kdd(n)
! Working variables
    INTEGER :: ii
! EXECUTION
    kd = 0.0
    kdd = 0.0
    DO ii=1,n
      kdd = kdd + d(ii)*kd0(:, ii) + k(:, ii)*dd(ii)
      kd = kd + k(:, ii)*d(ii)
    END DO
  END SUBROUTINE MATDOTVEC_D

!  Differentiation of matdotvec in reverse (adjoint) mode:
!   gradient     of useful results: d k kd
!   with respect to varying inputs: d k
!============================================================
  SUBROUTINE MATDOTVEC_B(n, k, kb, d, db, kd, kdb)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n
    REAL, INTENT(IN) :: k(n, n), d(n)
    REAL :: kb(n, n), db(n)
! Output variables
    REAL :: kd(n)
    REAL :: kdb(n)
! Working variables
    INTEGER :: ii
! EXECUTION
    CALL PUSHREAL4ARRAY(kd, n)
    kd = 0.0
    DO ii=1,n
      kd = kd + k(:, ii)*d(ii)
    END DO
    DO ii=n,1,-1
      kb(:, ii) = kb(:, ii) + d(ii)*kdb
      db(ii) = db(ii) + SUM(k(:, ii)*kdb)
    END DO
    CALL POPREAL4ARRAY(kd, n)
  END SUBROUTINE MATDOTVEC_B

!============================================================
  SUBROUTINE MATDOTVEC(n, k, d, kd)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n
    REAL, INTENT(IN) :: k(n, n), d(n)
! Output variables
    REAL, INTENT(OUT) :: kd(n)
! Working variables
    INTEGER :: ii
! EXECUTION
    kd = 0.0
    DO ii=1,n
      kd = kd + k(:, ii)*d(ii)
    END DO
  END SUBROUTINE MATDOTVEC

!  Differentiation of fem_main in forward (tangent) mode:
!   variations   of useful results: res mass ksmargin margins
!   with respect to varying inputs: d f t margins
!============================================================
  SUBROUTINE FEM_MAIN_D(n_beams, n_cons, x, r, t, td, f, fd, d, dd, e, &
&   rho, sigmay, pks, conids, res, resd, mass, massd, margins, marginsd&
&   , ksmargin, ksmargind)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_beams, n_cons
    REAL, INTENT(IN) :: x(3, n_beams+1)
    REAL, INTENT(IN) :: r(n_beams), t(n_beams)
    REAL, INTENT(IN) :: td(n_beams)
    REAL, INTENT(IN) :: f(2*(n_beams+1)), d(2*(n_beams+1))
    REAL, INTENT(IN) :: fd(2*(n_beams+1)), dd(2*(n_beams+1))
    REAL, INTENT(IN) :: e, rho, sigmay, pks
    INTEGER, INTENT(IN) :: conids(n_cons)
! Output variables
    REAL, INTENT(OUT) :: res(2*(n_beams+1)), mass, margins(2*n_beams), &
&   ksmargin
    REAL, INTENT(OUT) :: resd(2*(n_beams+1)), massd, marginsd(2*n_beams)&
&   , ksmargind
! EXECUTION
! Call relevant subroutines
    CALL GET_RESIDUALS_D0(n_beams, n_cons, x, r, t, td, f, fd, d, dd, e&
&                   , conids, res, resd)
    CALL GET_FUNCTIONS_D0(n_beams, n_cons, x, r, t, td, f, d, dd, e, rho&
&                   , sigmay, pks, conids, mass, massd, margins, &
&                   marginsd, ksmargin, ksmargind)
  END SUBROUTINE FEM_MAIN_D

!  Differentiation of fem_main in reverse (adjoint) mode:
!   gradient     of useful results: res mass ksmargin margins
!   with respect to varying inputs: d f t margins
!============================================================
  SUBROUTINE FEM_MAIN_B(n_beams, n_cons, x, r, t, tb, f, fb, d, db, e, &
&   rho, sigmay, pks, conids, res, resb, mass, massb, margins, marginsb&
&   , ksmargin, ksmarginb)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_beams, n_cons
    REAL, INTENT(IN) :: x(3, n_beams+1)
    REAL, INTENT(IN) :: r(n_beams), t(n_beams)
    REAL :: tb(n_beams)
    REAL, INTENT(IN) :: f(2*(n_beams+1)), d(2*(n_beams+1))
    REAL :: fb(2*(n_beams+1)), db(2*(n_beams+1))
    REAL, INTENT(IN) :: e, rho, sigmay, pks
    INTEGER, INTENT(IN) :: conids(n_cons)
! Output variables
    REAL :: res(2*(n_beams+1)), mass, margins(2*n_beams), ksmargin
    REAL :: resb(2*(n_beams+1)), massb, marginsb(2*n_beams), ksmarginb
! EXECUTION
! Call relevant subroutines
    CALL GET_RESIDUALS(n_beams, n_cons, x, r, t, f, d, e, conids, res)
    CALL PUSHREAL4ARRAY(margins, 2*n_beams)
    CALL GET_FUNCTIONS(n_beams, n_cons, x, r, t, f, d, e, rho, sigmay, &
&                pks, conids, mass, margins, ksmargin)
    CALL POPREAL4ARRAY(margins, 2*n_beams)
    CALL GET_FUNCTIONS_B0(n_beams, n_cons, x, r, t, tb, f, d, db, e, rho&
&                   , sigmay, pks, conids, mass, massb, margins, &
&                   marginsb, ksmargin, ksmarginb)
    CALL GET_RESIDUALS_B0(n_beams, n_cons, x, r, t, tb, f, fb, d, db, e&
&                   , conids, res, resb)
  END SUBROUTINE FEM_MAIN_B

!============================================================
  SUBROUTINE FEM_MAIN(n_beams, n_cons, x, r, t, f, d, e, rho, sigmay, &
&   pks, conids, res, mass, margins, ksmargin)
    IMPLICIT NONE
! Input variables
    INTEGER, INTENT(IN) :: n_beams, n_cons
    REAL, INTENT(IN) :: x(3, n_beams+1)
    REAL, INTENT(IN) :: r(n_beams), t(n_beams)
    REAL, INTENT(IN) :: f(2*(n_beams+1)), d(2*(n_beams+1))
    REAL, INTENT(IN) :: e, rho, sigmay, pks
    INTEGER, INTENT(IN) :: conids(n_cons)
! Output variables
    REAL, INTENT(OUT) :: res(2*(n_beams+1)), mass, margins(2*n_beams), &
&   ksmargin
! EXECUTION
! Call relevant subroutines
    CALL GET_RESIDUALS(n_beams, n_cons, x, r, t, f, d, e, conids, res)
    CALL GET_FUNCTIONS(n_beams, n_cons, x, r, t, f, d, e, rho, sigmay, &
&                pks, conids, mass, margins, ksmargin)
  END SUBROUTINE FEM_MAIN

END MODULE FEM_MODULE_DIFF

